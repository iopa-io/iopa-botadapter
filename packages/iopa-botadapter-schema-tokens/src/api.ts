/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Microsoft Bot Token API - V3.1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: token
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url'
import * as portableFetch from 'portable-fetch'
import { Configuration } from './configuration'

const BASE_PATH = 'https://token.botframework.com'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string
    options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration

    constructor(
        configuration?: Configuration,
        protected basePath: string = BASE_PATH,
        protected fetch: FetchAPI = portableFetch
    ) {
        if (configuration) {
            this.configuration = configuration
            this.basePath = configuration.basePath || this.basePath
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: 'RequiredError'
    constructor(public field: string, msg?: string) {
        super(msg)
    }
}

/**
 *
 * @export
 * @interface AadResourceUrls
 */
export interface AadResourceUrls {
    /**
     *
     * @type {Array<string>}
     * @memberof AadResourceUrls
     */
    resourceUrls?: Array<string>
}

/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     *
     * @type {Error}
     * @memberof ErrorResponse
     */
    error?: Error
}

/**
 *
 * @export
 * @interface InnerHttpError
 */
export interface InnerHttpError {
    /**
     *
     * @type {number}
     * @memberof InnerHttpError
     */
    statusCode?: number
    /**
     *
     * @type {any}
     * @memberof InnerHttpError
     */
    body?: any
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    code?: string
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    message?: string
    /**
     *
     * @type {InnerHttpError}
     * @memberof ModelError
     */
    innerHttpError?: InnerHttpError
}

/**
 *
 * @export
 * @interface ModelVoid
 */
export interface ModelVoid {}

/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     *
     * @type {string}
     * @memberof TokenResponse
     */
    channelId?: string
    /**
     *
     * @type {string}
     * @memberof TokenResponse
     */
    connectionName?: string
    /**
     *
     * @type {string}
     * @memberof TokenResponse
     */
    token?: string
    /**
     *
     * @type {string}
     * @memberof TokenResponse
     */
    expiration?: string
}

/**
 * The status of a particular token
 * @export
 * @interface TokenStatus
 */
export interface TokenStatus {
    /**
     * The channelId of the token status pertains to
     * @type {string}
     * @memberof TokenStatus
     */
    channelId?: string
    /**
     * The name of the connection the token status pertains to
     * @type {string}
     * @memberof TokenStatus
     */
    connectionName?: string
    /**
     * True if a token is stored for this ConnectionName
     * @type {boolean}
     * @memberof TokenStatus
     */
    hasToken?: boolean
    /**
     * The display name of the service provider for which this Token belongs to
     * @type {string}
     * @memberof TokenStatus
     */
    serviceProviderDisplayName?: string
}

/**
 * BotSignInApi - fetch parameter creator
 * @export
 */
export const BotSignInApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @param {string} state
         * @param {string} [codeChallenge]
         * @param {string} [emulatorUrl]
         * @param {string} [finalRedirect]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botSignInGetSignInUrl(
            state: string,
            codeChallenge?: string,
            emulatorUrl?: string,
            finalRedirect?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError(
                    'state',
                    'Required parameter state was null or undefined when calling botSignInGetSignInUrl.'
                )
            }
            const localVarPath = `/api/botsignin/GetSignInUrl`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            if (state !== undefined) {
                localVarQueryParameter['state'] = state
            }

            if (codeChallenge !== undefined) {
                localVarQueryParameter['code_challenge'] = codeChallenge
            }

            if (emulatorUrl !== undefined) {
                localVarQueryParameter['emulatorUrl'] = emulatorUrl
            }

            if (finalRedirect !== undefined) {
                localVarQueryParameter['finalRedirect'] = finalRedirect
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * BotSignInApi - functional programming interface
 * @export
 */
export const BotSignInApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} state
         * @param {string} [codeChallenge]
         * @param {string} [emulatorUrl]
         * @param {string} [finalRedirect]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botSignInGetSignInUrl(
            state: string,
            codeChallenge?: string,
            emulatorUrl?: string,
            finalRedirect?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BotSignInApiFetchParamCreator(
                configuration
            ).botSignInGetSignInUrl(
                state,
                codeChallenge,
                emulatorUrl,
                finalRedirect,
                options
            )
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
    }
}

/**
 * BotSignInApi - factory interface
 * @export
 */
export const BotSignInApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @param {string} state
         * @param {string} [codeChallenge]
         * @param {string} [emulatorUrl]
         * @param {string} [finalRedirect]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botSignInGetSignInUrl(
            state: string,
            codeChallenge?: string,
            emulatorUrl?: string,
            finalRedirect?: string,
            options?: any
        ) {
            return BotSignInApiFp(configuration).botSignInGetSignInUrl(
                state,
                codeChallenge,
                emulatorUrl,
                finalRedirect,
                options
            )(fetch, basePath)
        },
    }
}

/**
 * BotSignInApi - interface
 * @export
 * @interface BotSignInApi
 */
export interface BotSignInApiInterface {
    /**
     *
     * @param {string} state
     * @param {string} [codeChallenge]
     * @param {string} [emulatorUrl]
     * @param {string} [finalRedirect]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotSignInApiInterface
     */
    botSignInGetSignInUrl(
        state: string,
        codeChallenge?: string,
        emulatorUrl?: string,
        finalRedirect?: string,
        options?: any
    ): Promise<string>
}

/**
 * BotSignInApi - object-oriented interface
 * @export
 * @class BotSignInApi
 * @extends {BaseAPI}
 */
export class BotSignInApi extends BaseAPI implements BotSignInApiInterface {
    /**
     *
     * @param {string} state
     * @param {string} [codeChallenge]
     * @param {string} [emulatorUrl]
     * @param {string} [finalRedirect]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotSignInApi
     */
    public botSignInGetSignInUrl(
        state: string,
        codeChallenge?: string,
        emulatorUrl?: string,
        finalRedirect?: string,
        options?: any
    ) {
        return BotSignInApiFp(this.configuration).botSignInGetSignInUrl(
            state,
            codeChallenge,
            emulatorUrl,
            finalRedirect,
            options
        )(this.fetch, this.basePath)
    }
}

/**
 * UserTokenApi - fetch parameter creator
 * @export
 */
export const UserTokenApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {AadResourceUrls} aadResourceUrls
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetAadTokens(
            userId: string,
            connectionName: string,
            aadResourceUrls: AadResourceUrls,
            channelId?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError(
                    'userId',
                    'Required parameter userId was null or undefined when calling userTokenGetAadTokens.'
                )
            }
            // verify required parameter 'connectionName' is not null or undefined
            if (connectionName === null || connectionName === undefined) {
                throw new RequiredError(
                    'connectionName',
                    'Required parameter connectionName was null or undefined when calling userTokenGetAadTokens.'
                )
            }
            // verify required parameter 'aadResourceUrls' is not null or undefined
            if (aadResourceUrls === null || aadResourceUrls === undefined) {
                throw new RequiredError(
                    'aadResourceUrls',
                    'Required parameter aadResourceUrls was null or undefined when calling userTokenGetAadTokens.'
                )
            }
            const localVarPath = `/api/usertoken/GetAadTokens`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            )
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId
            }

            if (connectionName !== undefined) {
                localVarQueryParameter['connectionName'] = connectionName
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId
            }

            localVarHeaderParameter['Content-Type'] = 'application/json'

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            const needsSerialization =
                <any>'AadResourceUrls' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json'
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(aadResourceUrls || {})
                : aadResourceUrls || ''

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {string} [channelId]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetToken(
            userId: string,
            connectionName: string,
            channelId?: string,
            code?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError(
                    'userId',
                    'Required parameter userId was null or undefined when calling userTokenGetToken.'
                )
            }
            // verify required parameter 'connectionName' is not null or undefined
            if (connectionName === null || connectionName === undefined) {
                throw new RequiredError(
                    'connectionName',
                    'Required parameter connectionName was null or undefined when calling userTokenGetToken.'
                )
            }
            const localVarPath = `/api/usertoken/GetToken`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId
            }

            if (connectionName !== undefined) {
                localVarQueryParameter['connectionName'] = connectionName
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         *
         * @param {string} userId
         * @param {string} [channelId]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetTokenStatus(
            userId: string,
            channelId?: string,
            include?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError(
                    'userId',
                    'Required parameter userId was null or undefined when calling userTokenGetTokenStatus.'
                )
            }
            const localVarPath = `/api/usertoken/GetTokenStatus`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         *
         * @param {string} userId
         * @param {string} [connectionName]
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenSignOut(
            userId: string,
            connectionName?: string,
            channelId?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError(
                    'userId',
                    'Required parameter userId was null or undefined when calling userTokenSignOut.'
                )
            }
            const localVarPath = `/api/usertoken/SignOut`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            )
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId
            }

            if (connectionName !== undefined) {
                localVarQueryParameter['connectionName'] = connectionName
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * UserTokenApi - functional programming interface
 * @export
 */
export const UserTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {AadResourceUrls} aadResourceUrls
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetAadTokens(
            userId: string,
            connectionName: string,
            aadResourceUrls: AadResourceUrls,
            channelId?: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<{ [key: string]: TokenResponse }> {
            const localVarFetchArgs = UserTokenApiFetchParamCreator(
                configuration
            ).userTokenGetAadTokens(
                userId,
                connectionName,
                aadResourceUrls,
                channelId,
                options
            )
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {string} [channelId]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetToken(
            userId: string,
            connectionName: string,
            channelId?: string,
            code?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<TokenResponse> {
            const localVarFetchArgs = UserTokenApiFetchParamCreator(
                configuration
            ).userTokenGetToken(
                userId,
                connectionName,
                channelId,
                code,
                options
            )
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         *
         * @param {string} userId
         * @param {string} [channelId]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetTokenStatus(
            userId: string,
            channelId?: string,
            include?: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<TokenStatus>> {
            const localVarFetchArgs = UserTokenApiFetchParamCreator(
                configuration
            ).userTokenGetTokenStatus(userId, channelId, include, options)
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         *
         * @param {string} userId
         * @param {string} [connectionName]
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenSignOut(
            userId: string,
            connectionName?: string,
            channelId?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoid> {
            const localVarFetchArgs = UserTokenApiFetchParamCreator(
                configuration
            ).userTokenSignOut(userId, connectionName, channelId, options)
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
    }
}

/**
 * UserTokenApi - factory interface
 * @export
 */
export const UserTokenApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {AadResourceUrls} aadResourceUrls
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetAadTokens(
            userId: string,
            connectionName: string,
            aadResourceUrls: AadResourceUrls,
            channelId?: string,
            options?: any
        ) {
            return UserTokenApiFp(configuration).userTokenGetAadTokens(
                userId,
                connectionName,
                aadResourceUrls,
                channelId,
                options
            )(fetch, basePath)
        },
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {string} [channelId]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetToken(
            userId: string,
            connectionName: string,
            channelId?: string,
            code?: string,
            options?: any
        ) {
            return UserTokenApiFp(configuration).userTokenGetToken(
                userId,
                connectionName,
                channelId,
                code,
                options
            )(fetch, basePath)
        },
        /**
         *
         * @param {string} userId
         * @param {string} [channelId]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetTokenStatus(
            userId: string,
            channelId?: string,
            include?: string,
            options?: any
        ) {
            return UserTokenApiFp(configuration).userTokenGetTokenStatus(
                userId,
                channelId,
                include,
                options
            )(fetch, basePath)
        },
        /**
         *
         * @param {string} userId
         * @param {string} [connectionName]
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenSignOut(
            userId: string,
            connectionName?: string,
            channelId?: string,
            options?: any
        ) {
            return UserTokenApiFp(configuration).userTokenSignOut(
                userId,
                connectionName,
                channelId,
                options
            )(fetch, basePath)
        },
    }
}

/**
 * UserTokenApi - interface
 * @export
 * @interface UserTokenApi
 */
export interface UserTokenApiInterface {
    /**
     *
     * @param {string} userId
     * @param {string} connectionName
     * @param {AadResourceUrls} aadResourceUrls
     * @param {string} [channelId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApiInterface
     */
    userTokenGetAadTokens(
        userId: string,
        connectionName: string,
        aadResourceUrls: AadResourceUrls,
        channelId?: string,
        options?: any
    ): Promise<{ [key: string]: TokenResponse }>

    /**
     *
     * @param {string} userId
     * @param {string} connectionName
     * @param {string} [channelId]
     * @param {string} [code]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApiInterface
     */
    userTokenGetToken(
        userId: string,
        connectionName: string,
        channelId?: string,
        code?: string,
        options?: any
    ): Promise<TokenResponse>

    /**
     *
     * @param {string} userId
     * @param {string} [channelId]
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApiInterface
     */
    userTokenGetTokenStatus(
        userId: string,
        channelId?: string,
        include?: string,
        options?: any
    ): Promise<Array<TokenStatus>>

    /**
     *
     * @param {string} userId
     * @param {string} [connectionName]
     * @param {string} [channelId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApiInterface
     */
    userTokenSignOut(
        userId: string,
        connectionName?: string,
        channelId?: string,
        options?: any
    ): Promise<ModelVoid>
}

/**
 * UserTokenApi - object-oriented interface
 * @export
 * @class UserTokenApi
 * @extends {BaseAPI}
 */
export class UserTokenApi extends BaseAPI implements UserTokenApiInterface {
    /**
     *
     * @param {string} userId
     * @param {string} connectionName
     * @param {AadResourceUrls} aadResourceUrls
     * @param {string} [channelId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApi
     */
    public userTokenGetAadTokens(
        userId: string,
        connectionName: string,
        aadResourceUrls: AadResourceUrls,
        channelId?: string,
        options?: any
    ) {
        return UserTokenApiFp(this.configuration).userTokenGetAadTokens(
            userId,
            connectionName,
            aadResourceUrls,
            channelId,
            options
        )(this.fetch, this.basePath)
    }

    /**
     *
     * @param {string} userId
     * @param {string} connectionName
     * @param {string} [channelId]
     * @param {string} [code]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApi
     */
    public userTokenGetToken(
        userId: string,
        connectionName: string,
        channelId?: string,
        code?: string,
        options?: any
    ) {
        return UserTokenApiFp(this.configuration).userTokenGetToken(
            userId,
            connectionName,
            channelId,
            code,
            options
        )(this.fetch, this.basePath)
    }

    /**
     *
     * @param {string} userId
     * @param {string} [channelId]
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApi
     */
    public userTokenGetTokenStatus(
        userId: string,
        channelId?: string,
        include?: string,
        options?: any
    ) {
        return UserTokenApiFp(this.configuration).userTokenGetTokenStatus(
            userId,
            channelId,
            include,
            options
        )(this.fetch, this.basePath)
    }

    /**
     *
     * @param {string} userId
     * @param {string} [connectionName]
     * @param {string} [channelId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApi
     */
    public userTokenSignOut(
        userId: string,
        connectionName?: string,
        channelId?: string,
        options?: any
    ) {
        return UserTokenApiFp(this.configuration).userTokenSignOut(
            userId,
            connectionName,
            channelId,
            options
        )(this.fetch, this.basePath)
    }
}
