/**
 * Microsoft Bot Connector API - v3.0
 * The Bot Connector REST API allows your bot to send and receive messages to channels configured in the  [Bot Framework Developer Portal](https://dev.botframework.com). The Connector service uses industry-standard REST  and JSON over HTTPS.    Client libraries for this REST API are available. See below for a list.    Many bots will use both the Bot Connector REST API and the associated [Bot State REST API](/en-us/restapi/state). The  Bot State REST API allows a bot to store and retrieve state associated with users and conversations.    Authentication for both the Bot Connector and Bot State REST APIs is accomplished with JWT Bearer tokens, and is  described in detail in the [Connector Authentication](/en-us/restapi/authentication) document.    # Client Libraries for the Bot Connector REST API    * [Bot Builder for C#](/en-us/csharp/builder/sdkreference/)  * [Bot Builder for Node.js](/en-us/node/builder/overview/)  * Generate your own from the [Connector API Swagger file](https://raw.githubusercontent.com/Microsoft/BotBuilder/master/CSharp/Library/Microsoft.Bot.Connector.Shared/Swagger/ConnectorAPI.json)    Â© 2016 Microsoft
 *
 * OpenAPI spec version: v3
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/// <reference path="../src/custom.d.ts" />
import { Configuration } from './configuration'
/**
 *
 * @export
 */
export declare const COLLECTION_FORMATS: {
    csv: string
    ssv: string
    tsv: string
    pipes: string
}
/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>
}
/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string
    options: any
}
/**
 *
 * @export
 * @class BaseAPI
 */
export declare class BaseAPI {
    protected basePath: string
    protected fetch: FetchAPI
    protected configuration: Configuration
    constructor(
        configuration?: Configuration,
        basePath?: string,
        fetch?: FetchAPI
    )
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export declare class RequiredError extends Error {
    field: string
    name: 'RequiredError'
    constructor(field: string, msg?: string)
}
/**
 * Defines action types for clickable buttons.
 * @export
 * @enum {string}
 */
export declare enum ActionTypes {
    OpenUrl,
    ImBack,
    PostBack,
    PlayAudio,
    PlayVideo,
    ShowImage,
    DownloadFile,
    Signin,
    Call,
    Payment,
    MessageBack,
}
/**
 * An Activity is the basic communication type for the Bot Framework 3.0 protocol.
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * Contains the activity type.
     * @type {ActivityTypes}
     * @memberof Activity
     */
    type?: ActivityTypes
    /**
     * Contains an ID that uniquely identifies the activity on the channel.
     * @type {string}
     * @memberof Activity
     */
    id?: string
    /**
     * Contains the date and time that the message was sent, in UTC, expressed in ISO-8601 format.
     * @type {Date}
     * @memberof Activity
     */
    timestamp?: Date
    /**
     * Contains the local date and time of the message, expressed in ISO-8601 format.  For example, 2016-09-23T13:07:49.4714686-07:00.
     * @type {Date}
     * @memberof Activity
     */
    localTimestamp?: Date
    /**
     * Contains the name of the local timezone of the message, expressed in IANA Time Zone database format.  For example, America/Los_Angeles.
     * @type {string}
     * @memberof Activity
     */
    localTimezone?: string
    /**
     * A string containing an IRI identifying the caller of a bot. This field is not intended to be transmitted  over the wire, but is instead populated by bots and clients based on cryptographically verifiable data  that asserts the identity of the callers (e.g. tokens).
     * @type {string}
     * @memberof Activity
     */
    callerId?: string
    /**
     * Contains the URL that specifies the channel's service endpoint. Set by the channel.
     * @type {string}
     * @memberof Activity
     */
    serviceUrl?: string
    /**
     * Contains an ID that uniquely identifies the channel. Set by the channel.
     * @type {string}
     * @memberof Activity
     */
    channelId?: string
    /**
     * Identifies the sender of the message.
     * @type {ChannelAccount}
     * @memberof Activity
     */
    from?: ChannelAccount
    /**
     * Identifies the conversation to which the activity belongs.
     * @type {ConversationAccount}
     * @memberof Activity
     */
    conversation?: ConversationAccount
    /**
     * Identifies the recipient of the message.
     * @type {ChannelAccount}
     * @memberof Activity
     */
    recipient?: ChannelAccount
    /**
     * Format of text fields Default:markdown
     * @type {TextFormatTypes}
     * @memberof Activity
     */
    textFormat?: TextFormatTypes
    /**
     * The layout hint for multiple attachments. Default: list.
     * @type {AttachmentLayoutTypes}
     * @memberof Activity
     */
    attachmentLayout?: AttachmentLayoutTypes
    /**
     * The collection of members added to the conversation.
     * @type {Array<ChannelAccount>}
     * @memberof Activity
     */
    membersAdded?: Array<ChannelAccount>
    /**
     * The collection of members removed from the conversation.
     * @type {Array<ChannelAccount>}
     * @memberof Activity
     */
    membersRemoved?: Array<ChannelAccount>
    /**
     * The collection of reactions added to the conversation.
     * @type {Array<MessageReaction>}
     * @memberof Activity
     */
    reactionsAdded?: Array<MessageReaction>
    /**
     * The collection of reactions removed from the conversation.
     * @type {Array<MessageReaction>}
     * @memberof Activity
     */
    reactionsRemoved?: Array<MessageReaction>
    /**
     * The updated topic name of the conversation.
     * @type {string}
     * @memberof Activity
     */
    topicName?: string
    /**
     * Indicates whether the prior history of the channel is disclosed.
     * @type {boolean}
     * @memberof Activity
     */
    historyDisclosed?: boolean
    /**
     * A locale name for the contents of the text field.  The locale name is a combination of an ISO 639 two- or three-letter culture code associated with a language  and an ISO 3166 two-letter subculture code associated with a country or region.  The locale name can also correspond to a valid BCP-47 language tag.
     * @type {string}
     * @memberof Activity
     */
    locale?: string
    /**
     * The text content of the message.
     * @type {string}
     * @memberof Activity
     */
    text?: string
    /**
     * The text to speak.
     * @type {string}
     * @memberof Activity
     */
    speak?: string
    /**
     * Indicates whether your bot is accepting,  expecting, or ignoring user input after the message is delivered to the client.
     * @type {InputHints}
     * @memberof Activity
     */
    inputHint?: InputHints
    /**
     * The text to display if the channel cannot render cards.
     * @type {string}
     * @memberof Activity
     */
    summary?: string
    /**
     * The suggested actions for the activity.
     * @type {SuggestedActions}
     * @memberof Activity
     */
    suggestedActions?: SuggestedActions
    /**
     * Attachments
     * @type {Array<Attachment>}
     * @memberof Activity
     */
    attachments?: Array<Attachment>
    /**
     * Represents the entities that were mentioned in the message.
     * @type {Array<Entity>}
     * @memberof Activity
     */
    entities?: Array<Entity>
    /**
     * Contains channel-specific content.
     * @type {any}
     * @memberof Activity
     */
    channelData?: any
    /**
     * Indicates whether the recipient of a contactRelationUpdate was added or removed from the sender's contact list.
     * @type {string}
     * @memberof Activity
     */
    action?: string
    /**
     * Contains the ID of the message to which this message is a reply.
     * @type {string}
     * @memberof Activity
     */
    replyToId?: string
    /**
     * A descriptive label for the activity.
     * @type {string}
     * @memberof Activity
     */
    label?: string
    /**
     * The type of the activity's value object.
     * @type {string}
     * @memberof Activity
     */
    valueType?: string
    /**
     * A value that is associated with the activity.
     * @type {any}
     * @memberof Activity
     */
    value?: any
    /**
     * The name of the operation associated with an invoke or event activity.
     * @type {string}
     * @memberof Activity
     */
    name?: string
    /**
     * A reference to another conversation or activity.
     * @type {ConversationReference}
     * @memberof Activity
     */
    relatesTo?: ConversationReference
    /**
     * The a code for endOfConversation activities that indicates why the conversation ended.
     * @type {EndOfConversationCodes}
     * @memberof Activity
     */
    code?: EndOfConversationCodes
    /**
     * The time at which the activity should be considered to be \"expired\" and should not be presented to the recipient.
     * @type {Date}
     * @memberof Activity
     */
    expiration?: Date
    /**
     * The importance of the activity.
     * @type {ActivityImportance}
     * @memberof Activity
     */
    importance?: ActivityImportance
    /**
     * A delivery hint to signal to the recipient alternate delivery paths for the activity.  The default delivery mode is \"default\".
     * @type {DeliveryModes}
     * @memberof Activity
     */
    deliveryMode?: DeliveryModes
    /**
     * List of phrases and references that speech and language priming systems should listen for
     * @type {Array<string>}
     * @memberof Activity
     */
    listenFor?: Array<string>
    /**
     * The collection of text fragments to highlight when the activity contains a ReplyToId value.
     * @type {Array<TextHighlight>}
     * @memberof Activity
     */
    textHighlights?: Array<TextHighlight>
    /**
     * An optional programmatic action accompanying this request
     * @type {SemanticAction}
     * @memberof Activity
     */
    semanticAction?: SemanticAction
}
/**
 * Defines the importance of an Activity
 * @export
 * @enum {string}
 */
export declare enum ActivityImportance {
    Low,
    Normal,
    High,
}
/**
 * Types of Activities
 * @export
 * @enum {string}
 */
export declare enum ActivityTypes {
    Message,
    ContactRelationUpdate,
    ConversationUpdate,
    Typing,
    EndOfConversation,
    Event,
    Invoke,
    DeleteUserData,
    MessageUpdate,
    MessageDelete,
    InstallationUpdate,
    MessageReaction,
    Suggestion,
    Trace,
    Handoff,
    Call,
    MessageStatus,
    CallStatus,
}
/**
 * An animation card (Ex: gif or short video clip)
 * @export
 * @interface AnimationCard
 */
export interface AnimationCard {
    /**
     * Title of this card
     * @type {string}
     * @memberof AnimationCard
     */
    title?: string
    /**
     * Subtitle of this card
     * @type {string}
     * @memberof AnimationCard
     */
    subtitle?: string
    /**
     * Text of this card
     * @type {string}
     * @memberof AnimationCard
     */
    text?: string
    /**
     * Thumbnail placeholder
     * @type {ThumbnailUrl}
     * @memberof AnimationCard
     */
    image?: ThumbnailUrl
    /**
     * Media URLs for this card. When this field contains more than one URL, each URL is an alternative format of the same content.
     * @type {Array<MediaUrl>}
     * @memberof AnimationCard
     */
    media?: Array<MediaUrl>
    /**
     * Actions on this card
     * @type {Array<CardAction>}
     * @memberof AnimationCard
     */
    buttons?: Array<CardAction>
    /**
     * This content may be shared with others (default:true)
     * @type {boolean}
     * @memberof AnimationCard
     */
    shareable?: boolean
    /**
     * Should the client loop playback at end of content (default:true)
     * @type {boolean}
     * @memberof AnimationCard
     */
    autoloop?: boolean
    /**
     * Should the client automatically start playback of media in this card (default:true)
     * @type {boolean}
     * @memberof AnimationCard
     */
    autostart?: boolean
    /**
     * Aspect ratio of thumbnail/media placeholder. Allowed values are \"16:9\" and \"4:3\"
     * @type {string}
     * @memberof AnimationCard
     */
    aspect?: string
    /**
     * Describes the length of the media content without requiring a receiver to open the content. Formatted as an ISO 8601 Duration field.
     * @type {string}
     * @memberof AnimationCard
     */
    duration?: string
    /**
     * Supplementary parameter for this card
     * @type {any}
     * @memberof AnimationCard
     */
    value?: any
}
/**
 * An attachment within an activity
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * mimetype/Contenttype for the file
     * @type {string}
     * @memberof Attachment
     */
    contentType?: string
    /**
     * Content Url
     * @type {string}
     * @memberof Attachment
     */
    contentUrl?: string
    /**
     * Embedded content
     * @type {any}
     * @memberof Attachment
     */
    content?: any
    /**
     * (OPTIONAL) The name of the attachment
     * @type {string}
     * @memberof Attachment
     */
    name?: string
    /**
     * (OPTIONAL) Thumbnail associated with attachment
     * @type {string}
     * @memberof Attachment
     */
    thumbnailUrl?: string
}
/**
 * Attachment data
 * @export
 * @interface AttachmentData
 */
export interface AttachmentData {
    /**
     * Content-Type of the attachment
     * @type {string}
     * @memberof AttachmentData
     */
    type?: string
    /**
     * Name of the attachment
     * @type {string}
     * @memberof AttachmentData
     */
    name?: string
    /**
     * Attachment content
     * @type {string}
     * @memberof AttachmentData
     */
    originalBase64?: string
    /**
     * Attachment thumbnail
     * @type {string}
     * @memberof AttachmentData
     */
    thumbnailBase64?: string
}
/**
 * Metadata for an attachment
 * @export
 * @interface AttachmentInfo
 */
export interface AttachmentInfo {
    /**
     * Name of the attachment
     * @type {string}
     * @memberof AttachmentInfo
     */
    name?: string
    /**
     * ContentType of the attachment
     * @type {string}
     * @memberof AttachmentInfo
     */
    type?: string
    /**
     * attachment views
     * @type {Array<AttachmentView>}
     * @memberof AttachmentInfo
     */
    views?: Array<AttachmentView>
}
/**
 * Attachment layout types
 * @export
 * @enum {string}
 */
export declare enum AttachmentLayoutTypes {
    List,
    Carousel,
}
/**
 * Attachment View name and size
 * @export
 * @interface AttachmentView
 */
export interface AttachmentView {
    /**
     * Id of the attachment
     * @type {string}
     * @memberof AttachmentView
     */
    viewId?: string
    /**
     * Size of the attachment
     * @type {number}
     * @memberof AttachmentView
     */
    size?: number
}
/**
 * Audio card
 * @export
 * @interface AudioCard
 */
export interface AudioCard {
    /**
     * Title of this card
     * @type {string}
     * @memberof AudioCard
     */
    title?: string
    /**
     * Subtitle of this card
     * @type {string}
     * @memberof AudioCard
     */
    subtitle?: string
    /**
     * Text of this card
     * @type {string}
     * @memberof AudioCard
     */
    text?: string
    /**
     * Thumbnail placeholder
     * @type {ThumbnailUrl}
     * @memberof AudioCard
     */
    image?: ThumbnailUrl
    /**
     * Media URLs for this card. When this field contains more than one URL, each URL is an alternative format of the same content.
     * @type {Array<MediaUrl>}
     * @memberof AudioCard
     */
    media?: Array<MediaUrl>
    /**
     * Actions on this card
     * @type {Array<CardAction>}
     * @memberof AudioCard
     */
    buttons?: Array<CardAction>
    /**
     * This content may be shared with others (default:true)
     * @type {boolean}
     * @memberof AudioCard
     */
    shareable?: boolean
    /**
     * Should the client loop playback at end of content (default:true)
     * @type {boolean}
     * @memberof AudioCard
     */
    autoloop?: boolean
    /**
     * Should the client automatically start playback of media in this card (default:true)
     * @type {boolean}
     * @memberof AudioCard
     */
    autostart?: boolean
    /**
     * Aspect ratio of thumbnail/media placeholder. Allowed values are \"16:9\" and \"4:3\"
     * @type {string}
     * @memberof AudioCard
     */
    aspect?: string
    /**
     * Describes the length of the media content without requiring a receiver to open the content. Formatted as an ISO 8601 Duration field.
     * @type {string}
     * @memberof AudioCard
     */
    duration?: string
    /**
     * Supplementary parameter for this card
     * @type {any}
     * @memberof AudioCard
     */
    value?: any
}
/**
 * A basic card
 * @export
 * @interface BasicCard
 */
export interface BasicCard {
    /**
     * Title of the card
     * @type {string}
     * @memberof BasicCard
     */
    title?: string
    /**
     * Subtitle of the card
     * @type {string}
     * @memberof BasicCard
     */
    subtitle?: string
    /**
     * Text for the card
     * @type {string}
     * @memberof BasicCard
     */
    text?: string
    /**
     * Array of images for the card
     * @type {Array<CardImage>}
     * @memberof BasicCard
     */
    images?: Array<CardImage>
    /**
     * Set of actions applicable to the current card
     * @type {Array<CardAction>}
     * @memberof BasicCard
     */
    buttons?: Array<CardAction>
    /**
     * This action will be activated when user taps on the card itself
     * @type {CardAction}
     * @memberof BasicCard
     */
    tap?: CardAction
}
/**
 * A clickable action
 * @export
 * @interface CardAction
 */
export interface CardAction {
    /**
     * The type of action implemented by this button
     * @type {ActionTypes}
     * @memberof CardAction
     */
    type?: ActionTypes
    /**
     * Text description which appears on the button
     * @type {string}
     * @memberof CardAction
     */
    title?: string
    /**
     * Image URL which will appear on the button, next to text label
     * @type {string}
     * @memberof CardAction
     */
    image?: string
    /**
     * Text for this action
     * @type {string}
     * @memberof CardAction
     */
    text?: string
    /**
     * (Optional) text to display in the chat feed if the button is clicked
     * @type {string}
     * @memberof CardAction
     */
    displayText?: string
    /**
     * Supplementary parameter for action. Content of this property depends on the ActionType
     * @type {any}
     * @memberof CardAction
     */
    value?: any
    /**
     * Channel-specific data associated with this action
     * @type {any}
     * @memberof CardAction
     */
    channelData?: any
}
/**
 * An image on a card
 * @export
 * @interface CardImage
 */
export interface CardImage {
    /**
     * URL thumbnail image for major content property
     * @type {string}
     * @memberof CardImage
     */
    url?: string
    /**
     * Image description intended for screen readers
     * @type {string}
     * @memberof CardImage
     */
    alt?: string
    /**
     * Action assigned to specific Attachment
     * @type {CardAction}
     * @memberof CardImage
     */
    tap?: CardAction
}
/**
 * Channel account information needed to route a message
 * @export
 * @interface ChannelAccount
 */
export interface ChannelAccount {
    /**
     * Channel id for the user or bot on this channel (Example: joe@smith.com, or @joesmith or 123456)
     * @type {string}
     * @memberof ChannelAccount
     */
    id?: string
    /**
     * Display friendly name
     * @type {string}
     * @memberof ChannelAccount
     */
    name?: string
    /**
     * This account's object ID within Azure Active Directory (AAD)
     * @type {string}
     * @memberof ChannelAccount
     */
    aadObjectId?: string
    /**
     * Role of the entity behind the account (Example: User, Bot, etc.)
     * @type {RoleTypes}
     * @memberof ChannelAccount
     */
    role?: RoleTypes
}
/**
 * Action types valid for ContactRelationUpdate activities
 * @export
 * @enum {string}
 */
export declare enum ContactRelationUpdateActionTypes {
    Add,
    Remove,
}
/**
 * Conversation account represents the identity of the conversation within a channel
 * @export
 * @interface ConversationAccount
 */
export interface ConversationAccount {
    /**
     * Indicates whether the conversation contains more than two participants at the time the activity was generated
     * @type {boolean}
     * @memberof ConversationAccount
     */
    isGroup?: boolean
    /**
     * Indicates the type of the conversation in channels that distinguish between conversation types
     * @type {string}
     * @memberof ConversationAccount
     */
    conversationType?: string
    /**
     * This conversation's tenant ID
     * @type {string}
     * @memberof ConversationAccount
     */
    tenantId?: string
    /**
     * Channel id for the user or bot on this channel (Example: joe@smith.com, or @joesmith or 123456)
     * @type {string}
     * @memberof ConversationAccount
     */
    id?: string
    /**
     * Display friendly name
     * @type {string}
     * @memberof ConversationAccount
     */
    name?: string
    /**
     * This account's object ID within Azure Active Directory (AAD)
     * @type {string}
     * @memberof ConversationAccount
     */
    aadObjectId?: string
    /**
     * Role of the entity behind the account (Example: User, Bot, etc.)
     * @type {RoleTypes}
     * @memberof ConversationAccount
     */
    role?: RoleTypes
}
/**
 * Conversation and its members
 * @export
 * @interface ConversationMembers
 */
export interface ConversationMembers {
    /**
     * Conversation ID
     * @type {string}
     * @memberof ConversationMembers
     */
    id?: string
    /**
     * List of members in this conversation
     * @type {Array<ChannelAccount>}
     * @memberof ConversationMembers
     */
    members?: Array<ChannelAccount>
}
/**
 * Parameters for creating a new conversation
 * @export
 * @interface ConversationParameters
 */
export interface ConversationParameters {
    /**
     * IsGroup
     * @type {boolean}
     * @memberof ConversationParameters
     */
    isGroup?: boolean
    /**
     * The bot address for this conversation
     * @type {ChannelAccount}
     * @memberof ConversationParameters
     */
    bot?: ChannelAccount
    /**
     * Members to add to the conversation
     * @type {Array<ChannelAccount>}
     * @memberof ConversationParameters
     */
    members?: Array<ChannelAccount>
    /**
     * (Optional) Topic of the conversation (if supported by the channel)
     * @type {string}
     * @memberof ConversationParameters
     */
    topicName?: string
    /**
     * (Optional) The tenant ID in which the conversation should be created
     * @type {string}
     * @memberof ConversationParameters
     */
    tenantId?: string
    /**
     * (Optional) When creating a new conversation, use this activity as the initial message to the conversation
     * @type {Activity}
     * @memberof ConversationParameters
     */
    activity?: Activity
    /**
     * Channel specific payload for creating the conversation
     * @type {any}
     * @memberof ConversationParameters
     */
    channelData?: any
}
/**
 * An object relating to a particular point in a conversation
 * @export
 * @interface ConversationReference
 */
export interface ConversationReference {
    /**
     * (Optional) ID of the activity to refer to
     * @type {string}
     * @memberof ConversationReference
     */
    activityId?: string
    /**
     * (Optional) User participating in this conversation
     * @type {ChannelAccount}
     * @memberof ConversationReference
     */
    user?: ChannelAccount
    /**
     * Bot participating in this conversation
     * @type {ChannelAccount}
     * @memberof ConversationReference
     */
    bot?: ChannelAccount
    /**
     * Conversation reference
     * @type {ConversationAccount}
     * @memberof ConversationReference
     */
    conversation?: ConversationAccount
    /**
     * Channel ID
     * @type {string}
     * @memberof ConversationReference
     */
    channelId?: string
    /**
     * Service endpoint where operations concerning the referenced conversation may be performed
     * @type {string}
     * @memberof ConversationReference
     */
    serviceUrl?: string
}
/**
 * A response containing a resource
 * @export
 * @interface ConversationResourceResponse
 */
export interface ConversationResourceResponse {
    /**
     * ID of the Activity (if sent)
     * @type {string}
     * @memberof ConversationResourceResponse
     */
    activityId?: string
    /**
     * Service endpoint where operations concerning the conversation may be performed
     * @type {string}
     * @memberof ConversationResourceResponse
     */
    serviceUrl?: string
    /**
     * Id of the resource
     * @type {string}
     * @memberof ConversationResourceResponse
     */
    id?: string
}
/**
 * Conversations result
 * @export
 * @interface ConversationsResult
 */
export interface ConversationsResult {
    /**
     * Paging token
     * @type {string}
     * @memberof ConversationsResult
     */
    continuationToken?: string
    /**
     * List of conversations
     * @type {Array<ConversationMembers>}
     * @memberof ConversationsResult
     */
    conversations?: Array<ConversationMembers>
}
/**
 * Values for deliveryMode field
 * @export
 * @enum {string}
 */
export declare enum DeliveryModes {
    Normal,
    Notification,
}
/**
 * Codes indicating why a conversation has ended
 * @export
 * @enum {string}
 */
export declare enum EndOfConversationCodes {
    Unknown,
    CompletedSuccessfully,
    UserCancelled,
    BotTimedOut,
    BotIssuedInvalidMessage,
    ChannelFailed,
}
/**
 * Metadata object pertaining to an activity
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * Type of this entity (RFC 3987 IRI)
     * @type {string}
     * @memberof Entity
     */
    type?: string
}
/**
 * An HTTP API response
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error message
     * @type {Error}
     * @memberof ErrorResponse
     */
    error?: Error
}
/**
 * Set of key-value pairs. Advantage of this section is that key and value properties will be   rendered with default style information with some delimiter between them. So there is no need for developer to specify style information.
 * @export
 * @interface Fact
 */
export interface Fact {
    /**
     * The key for this Fact
     * @type {string}
     * @memberof Fact
     */
    key?: string
    /**
     * The value for this Fact
     * @type {string}
     * @memberof Fact
     */
    value?: string
}
/**
 * GeoCoordinates (entity type: \"https://schema.org/GeoCoordinates\")
 * @export
 * @interface GeoCoordinates
 */
export interface GeoCoordinates {
    /**
     * Elevation of the location [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System)
     * @type {number}
     * @memberof GeoCoordinates
     */
    elevation?: number
    /**
     * Latitude of the location [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System)
     * @type {number}
     * @memberof GeoCoordinates
     */
    latitude?: number
    /**
     * Longitude of the location [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System)
     * @type {number}
     * @memberof GeoCoordinates
     */
    longitude?: number
    /**
     * The type of the thing
     * @type {string}
     * @memberof GeoCoordinates
     */
    type?: string
    /**
     * The name of the thing
     * @type {string}
     * @memberof GeoCoordinates
     */
    name?: string
}
/**
 * A Hero card (card with a single, large image)
 * @export
 * @interface HeroCard
 */
export interface HeroCard {
    /**
     * Title of the card
     * @type {string}
     * @memberof HeroCard
     */
    title?: string
    /**
     * Subtitle of the card
     * @type {string}
     * @memberof HeroCard
     */
    subtitle?: string
    /**
     * Text for the card
     * @type {string}
     * @memberof HeroCard
     */
    text?: string
    /**
     * Array of images for the card
     * @type {Array<CardImage>}
     * @memberof HeroCard
     */
    images?: Array<CardImage>
    /**
     * Set of actions applicable to the current card
     * @type {Array<CardAction>}
     * @memberof HeroCard
     */
    buttons?: Array<CardAction>
    /**
     * This action will be activated when user taps on the card itself
     * @type {CardAction}
     * @memberof HeroCard
     */
    tap?: CardAction
}
/**
 * Object representing inner http error
 * @export
 * @interface InnerHttpError
 */
export interface InnerHttpError {
    /**
     * HttpStatusCode from failed request
     * @type {number}
     * @memberof InnerHttpError
     */
    statusCode?: number
    /**
     * Body from failed request
     * @type {any}
     * @memberof InnerHttpError
     */
    body?: any
}
/**
 * Indicates whether the bot is accepting, expecting, or ignoring input
 * @export
 * @enum {string}
 */
export declare enum InputHints {
    AcceptingInput,
    IgnoringInput,
    ExpectingInput,
}
/**
 * Action types valid for InstallationUpdate activities
 * @export
 * @enum {string}
 */
export declare enum InstallationUpdateActionTypes {
    Add,
    Remove,
}
/**
 * Media card
 * @export
 * @interface MediaCard
 */
export interface MediaCard {
    /**
     * Title of this card
     * @type {string}
     * @memberof MediaCard
     */
    title?: string
    /**
     * Subtitle of this card
     * @type {string}
     * @memberof MediaCard
     */
    subtitle?: string
    /**
     * Text of this card
     * @type {string}
     * @memberof MediaCard
     */
    text?: string
    /**
     * Thumbnail placeholder
     * @type {ThumbnailUrl}
     * @memberof MediaCard
     */
    image?: ThumbnailUrl
    /**
     * Media URLs for this card. When this field contains more than one URL, each URL is an alternative format of the same content.
     * @type {Array<MediaUrl>}
     * @memberof MediaCard
     */
    media?: Array<MediaUrl>
    /**
     * Actions on this card
     * @type {Array<CardAction>}
     * @memberof MediaCard
     */
    buttons?: Array<CardAction>
    /**
     * This content may be shared with others (default:true)
     * @type {boolean}
     * @memberof MediaCard
     */
    shareable?: boolean
    /**
     * Should the client loop playback at end of content (default:true)
     * @type {boolean}
     * @memberof MediaCard
     */
    autoloop?: boolean
    /**
     * Should the client automatically start playback of media in this card (default:true)
     * @type {boolean}
     * @memberof MediaCard
     */
    autostart?: boolean
    /**
     * Aspect ratio of thumbnail/media placeholder. Allowed values are \"16:9\" and \"4:3\"
     * @type {string}
     * @memberof MediaCard
     */
    aspect?: string
    /**
     * Describes the length of the media content without requiring a receiver to open the content. Formatted as an ISO 8601 Duration field.
     * @type {string}
     * @memberof MediaCard
     */
    duration?: string
    /**
     * Supplementary parameter for this card
     * @type {any}
     * @memberof MediaCard
     */
    value?: any
}
/**
 * Supplementary parameter for media events
 * @export
 * @interface MediaEventValue
 */
export interface MediaEventValue {
    /**
     * Callback parameter specified in the Value field of the MediaCard that originated this event
     * @type {any}
     * @memberof MediaEventValue
     */
    cardValue?: any
}
/**
 * Media URL
 * @export
 * @interface MediaUrl
 */
export interface MediaUrl {
    /**
     * Url for the media
     * @type {string}
     * @memberof MediaUrl
     */
    url?: string
    /**
     * Optional profile hint to the client to differentiate multiple MediaUrl objects from each other
     * @type {string}
     * @memberof MediaUrl
     */
    profile?: string
}
/**
 * Mention information (entity type: \"mention\")
 * @export
 * @interface Mention
 */
export interface Mention {
    /**
     * The mentioned user
     * @type {ChannelAccount}
     * @memberof Mention
     */
    mentioned?: ChannelAccount
    /**
     * Sub Text which represents the mention (can be null or empty)
     * @type {string}
     * @memberof Mention
     */
    text?: string
    /**
     * Type of this entity (RFC 3987 IRI)
     * @type {string}
     * @memberof Mention
     */
    type?: string
}
/**
 * Message reaction object
 * @export
 * @interface MessageReaction
 */
export interface MessageReaction {
    /**
     * Message reaction type
     * @type {MessageReactionTypes}
     * @memberof MessageReaction
     */
    type?: MessageReactionTypes
}
/**
 * Message reaction types
 * @export
 * @enum {string}
 */
export declare enum MessageReactionTypes {
    Like,
    PlusOne,
}
/**
 * W3C Payment Method Data for Microsoft Pay
 * @export
 * @interface MicrosoftPayMethodData
 */
export interface MicrosoftPayMethodData {
    /**
     * Microsoft Pay Merchant ID
     * @type {string}
     * @memberof MicrosoftPayMethodData
     */
    merchantId?: string
    /**
     * Supported payment networks (e.g., \"visa\" and \"mastercard\")
     * @type {Array<string>}
     * @memberof MicrosoftPayMethodData
     */
    supportedNetworks?: Array<string>
    /**
     * Supported payment types (e.g., \"credit\")
     * @type {Array<string>}
     * @memberof MicrosoftPayMethodData
     */
    supportedTypes?: Array<string>
}
/**
 * Object representing error information
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error code
     * @type {string}
     * @memberof ModelError
     */
    code?: string
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    message?: string
    /**
     * Error from inner http call
     * @type {InnerHttpError}
     * @memberof ModelError
     */
    innerHttpError?: InnerHttpError
}
/**
 * A card representing a request to perform a sign in via OAuth
 * @export
 * @interface OAuthCard
 */
export interface OAuthCard {
    /**
     * Text for signin request
     * @type {string}
     * @memberof OAuthCard
     */
    text?: string
    /**
     * The name of the registered connection
     * @type {string}
     * @memberof OAuthCard
     */
    connectionName?: string
    /**
     * Action to use to perform signin
     * @type {Array<CardAction>}
     * @memberof OAuthCard
     */
    buttons?: Array<CardAction>
}
/**
 * Page of members.
 * @export
 * @interface PagedMembersResult
 */
export interface PagedMembersResult {
    /**
     * Paging token
     * @type {string}
     * @memberof PagedMembersResult
     */
    continuationToken?: string
    /**
     * The Channel Accounts.
     * @type {Array<ChannelAccount>}
     * @memberof PagedMembersResult
     */
    members?: Array<ChannelAccount>
}
/**
 * Address within a Payment Request
 * @export
 * @interface PaymentAddress
 */
export interface PaymentAddress {
    /**
     * This is the CLDR (Common Locale Data Repository) region code. For example, US, GB, CN, or JP
     * @type {string}
     * @memberof PaymentAddress
     */
    country?: string
    /**
     * This is the most specific part of the address. It can include, for example, a street name, a house number, apartment number, a rural delivery route, descriptive instructions, or a post office box number.
     * @type {Array<string>}
     * @memberof PaymentAddress
     */
    addressLine?: Array<string>
    /**
     * This is the top level administrative subdivision of the country. For example, this can be a state, a province, an oblast, or a prefecture.
     * @type {string}
     * @memberof PaymentAddress
     */
    region?: string
    /**
     * This is the city/town portion of the address.
     * @type {string}
     * @memberof PaymentAddress
     */
    city?: string
    /**
     * This is the dependent locality or sublocality within a city. For example, used for neighborhoods, boroughs, districts, or UK dependent localities.
     * @type {string}
     * @memberof PaymentAddress
     */
    dependentLocality?: string
    /**
     * This is the postal code or ZIP code, also known as PIN code in India.
     * @type {string}
     * @memberof PaymentAddress
     */
    postalCode?: string
    /**
     * This is the sorting code as used in, for example, France.
     * @type {string}
     * @memberof PaymentAddress
     */
    sortingCode?: string
    /**
     * This is the BCP-47 language code for the address. It's used to determine the field separators and the order of fields when formatting the address for display.
     * @type {string}
     * @memberof PaymentAddress
     */
    languageCode?: string
    /**
     * This is the organization, firm, company, or institution at this address.
     * @type {string}
     * @memberof PaymentAddress
     */
    organization?: string
    /**
     * This is the name of the recipient or contact person.
     * @type {string}
     * @memberof PaymentAddress
     */
    recipient?: string
    /**
     * This is the phone number of the recipient or contact person.
     * @type {string}
     * @memberof PaymentAddress
     */
    phone?: string
}
/**
 * Supplies monetary amounts
 * @export
 * @interface PaymentCurrencyAmount
 */
export interface PaymentCurrencyAmount {
    /**
     * A currency identifier
     * @type {string}
     * @memberof PaymentCurrencyAmount
     */
    currency?: string
    /**
     * Decimal monetary value
     * @type {string}
     * @memberof PaymentCurrencyAmount
     */
    value?: string
    /**
     * Currency system
     * @type {string}
     * @memberof PaymentCurrencyAmount
     */
    currencySystem?: string
}
/**
 * Provides information about the requested transaction
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
    /**
     * Contains the total amount of the payment request
     * @type {PaymentItem}
     * @memberof PaymentDetails
     */
    total?: PaymentItem
    /**
     * Contains line items for the payment request that the user agent may display
     * @type {Array<PaymentItem>}
     * @memberof PaymentDetails
     */
    displayItems?: Array<PaymentItem>
    /**
     * A sequence containing the different shipping options for the user to choose from
     * @type {Array<PaymentShippingOption>}
     * @memberof PaymentDetails
     */
    shippingOptions?: Array<PaymentShippingOption>
    /**
     * Contains modifiers for particular payment method identifiers
     * @type {Array<PaymentDetailsModifier>}
     * @memberof PaymentDetails
     */
    modifiers?: Array<PaymentDetailsModifier>
    /**
     * Error description
     * @type {string}
     * @memberof PaymentDetails
     */
    error?: string
}
/**
 * Provides details that modify the PaymentDetails based on payment method identifier
 * @export
 * @interface PaymentDetailsModifier
 */
export interface PaymentDetailsModifier {
    /**
     * Contains a sequence of payment method identifiers
     * @type {Array<string>}
     * @memberof PaymentDetailsModifier
     */
    supportedMethods?: Array<string>
    /**
     * This value overrides the total field in the PaymentDetails dictionary for the payment method identifiers in the supportedMethods field
     * @type {PaymentItem}
     * @memberof PaymentDetailsModifier
     */
    total?: PaymentItem
    /**
     * Provides additional display items that are appended to the displayItems field in the PaymentDetails dictionary for the payment method identifiers in the supportedMethods field
     * @type {Array<PaymentItem>}
     * @memberof PaymentDetailsModifier
     */
    additionalDisplayItems?: Array<PaymentItem>
    /**
     * A JSON-serializable object that provides optional information that might be needed by the supported payment methods
     * @type {any}
     * @memberof PaymentDetailsModifier
     */
    data?: any
}
/**
 * Indicates what the payment request is for and the value asked for
 * @export
 * @interface PaymentItem
 */
export interface PaymentItem {
    /**
     * Human-readable description of the item
     * @type {string}
     * @memberof PaymentItem
     */
    label?: string
    /**
     * Monetary amount for the item
     * @type {PaymentCurrencyAmount}
     * @memberof PaymentItem
     */
    amount?: PaymentCurrencyAmount
    /**
     * When set to true this flag means that the amount field is not final.
     * @type {boolean}
     * @memberof PaymentItem
     */
    pending?: boolean
}
/**
 * Indicates a set of supported payment methods and any associated payment method specific data for those methods
 * @export
 * @interface PaymentMethodData
 */
export interface PaymentMethodData {
    /**
     * Required sequence of strings containing payment method identifiers for payment methods that the merchant web site accepts
     * @type {Array<string>}
     * @memberof PaymentMethodData
     */
    supportedMethods?: Array<string>
    /**
     * A JSON-serializable object that provides optional information that might be needed by the supported payment methods
     * @type {any}
     * @memberof PaymentMethodData
     */
    data?: any
}
/**
 * Provides information about the options desired for the payment request
 * @export
 * @interface PaymentOptions
 */
export interface PaymentOptions {
    /**
     * Indicates whether the user agent should collect and return the payer's name as part of the payment request
     * @type {boolean}
     * @memberof PaymentOptions
     */
    requestPayerName?: boolean
    /**
     * Indicates whether the user agent should collect and return the payer's email address as part of the payment request
     * @type {boolean}
     * @memberof PaymentOptions
     */
    requestPayerEmail?: boolean
    /**
     * Indicates whether the user agent should collect and return the payer's phone number as part of the payment request
     * @type {boolean}
     * @memberof PaymentOptions
     */
    requestPayerPhone?: boolean
    /**
     * Indicates whether the user agent should collect and return a shipping address as part of the payment request
     * @type {boolean}
     * @memberof PaymentOptions
     */
    requestShipping?: boolean
    /**
     * If requestShipping is set to true, then the shippingType field may be used to influence the way the user agent presents the user interface for gathering the shipping address
     * @type {string}
     * @memberof PaymentOptions
     */
    shippingType?: string
}
/**
 * A request to make a payment
 * @export
 * @interface PaymentRequest
 */
export interface PaymentRequest {
    /**
     * ID of this payment request
     * @type {string}
     * @memberof PaymentRequest
     */
    id?: string
    /**
     * Allowed payment methods for this request
     * @type {Array<PaymentMethodData>}
     * @memberof PaymentRequest
     */
    methodData?: Array<PaymentMethodData>
    /**
     * Details for this request
     * @type {PaymentDetails}
     * @memberof PaymentRequest
     */
    details?: PaymentDetails
    /**
     * Provides information about the options desired for the payment request
     * @type {PaymentOptions}
     * @memberof PaymentRequest
     */
    options?: PaymentOptions
    /**
     * Expiration for this request, in ISO 8601 duration format (e.g., 'P1D')
     * @type {string}
     * @memberof PaymentRequest
     */
    expires?: string
}
/**
 * Payload delivered when completing a payment request
 * @export
 * @interface PaymentRequestComplete
 */
export interface PaymentRequestComplete {
    /**
     * Payment request ID
     * @type {string}
     * @memberof PaymentRequestComplete
     */
    id?: string
    /**
     * Initial payment request
     * @type {PaymentRequest}
     * @memberof PaymentRequestComplete
     */
    paymentRequest?: PaymentRequest
    /**
     * Corresponding payment response
     * @type {PaymentResponse}
     * @memberof PaymentRequestComplete
     */
    paymentResponse?: PaymentResponse
}
/**
 * Result from a completed payment request
 * @export
 * @interface PaymentRequestCompleteResult
 */
export interface PaymentRequestCompleteResult {
    /**
     * Result of the payment request completion
     * @type {string}
     * @memberof PaymentRequestCompleteResult
     */
    result?: string
}
/**
 * An update to a payment request
 * @export
 * @interface PaymentRequestUpdate
 */
export interface PaymentRequestUpdate {
    /**
     * ID for the payment request to update
     * @type {string}
     * @memberof PaymentRequestUpdate
     */
    id?: string
    /**
     * Update payment details
     * @type {PaymentDetails}
     * @memberof PaymentRequestUpdate
     */
    details?: PaymentDetails
    /**
     * Updated shipping address
     * @type {PaymentAddress}
     * @memberof PaymentRequestUpdate
     */
    shippingAddress?: PaymentAddress
    /**
     * Updated shipping options
     * @type {string}
     * @memberof PaymentRequestUpdate
     */
    shippingOption?: string
}
/**
 * A result object from a Payment Request Update invoke operation
 * @export
 * @interface PaymentRequestUpdateResult
 */
export interface PaymentRequestUpdateResult {
    /**
     * Update payment details
     * @type {PaymentDetails}
     * @memberof PaymentRequestUpdateResult
     */
    details?: PaymentDetails
}
/**
 * A PaymentResponse is returned when a user has selected a payment method and approved a payment request
 * @export
 * @interface PaymentResponse
 */
export interface PaymentResponse {
    /**
     * The payment method identifier for the payment method that the user selected to fulfil the transaction
     * @type {string}
     * @memberof PaymentResponse
     */
    methodName?: string
    /**
     * A JSON-serializable object that provides a payment method specific message used by the merchant to process the transaction and determine successful fund transfer
     * @type {any}
     * @memberof PaymentResponse
     */
    details?: any
    /**
     * If the requestShipping flag was set to true in the PaymentOptions passed to the PaymentRequest constructor, then shippingAddress will be the full and final shipping address chosen by the user
     * @type {PaymentAddress}
     * @memberof PaymentResponse
     */
    shippingAddress?: PaymentAddress
    /**
     * If the requestShipping flag was set to true in the PaymentOptions passed to the PaymentRequest constructor, then shippingOption will be the id attribute of the selected shipping option
     * @type {string}
     * @memberof PaymentResponse
     */
    shippingOption?: string
    /**
     * If the requestPayerEmail flag was set to true in the PaymentOptions passed to the PaymentRequest constructor, then payerEmail will be the email address chosen by the user
     * @type {string}
     * @memberof PaymentResponse
     */
    payerEmail?: string
    /**
     * If the requestPayerPhone flag was set to true in the PaymentOptions passed to the PaymentRequest constructor, then payerPhone will be the phone number chosen by the user
     * @type {string}
     * @memberof PaymentResponse
     */
    payerPhone?: string
}
/**
 * Describes a shipping option
 * @export
 * @interface PaymentShippingOption
 */
export interface PaymentShippingOption {
    /**
     * String identifier used to reference this PaymentShippingOption
     * @type {string}
     * @memberof PaymentShippingOption
     */
    id?: string
    /**
     * Human-readable description of the item
     * @type {string}
     * @memberof PaymentShippingOption
     */
    label?: string
    /**
     * Contains the monetary amount for the item
     * @type {PaymentCurrencyAmount}
     * @memberof PaymentShippingOption
     */
    amount?: PaymentCurrencyAmount
    /**
     * Indicates whether this is the default selected PaymentShippingOption
     * @type {boolean}
     * @memberof PaymentShippingOption
     */
    selected?: boolean
}
/**
 * Place (entity type: \"https://schema.org/Place\")
 * @export
 * @interface Place
 */
export interface Place {
    /**
     * Address of the place (may be `string` or complex object of type `PostalAddress`)
     * @type {any}
     * @memberof Place
     */
    address?: any
    /**
     * Geo coordinates of the place (may be complex object of type `GeoCoordinates` or `GeoShape`)
     * @type {any}
     * @memberof Place
     */
    geo?: any
    /**
     * Map to the place (may be `string` (URL) or complex object of type `Map`)
     * @type {any}
     * @memberof Place
     */
    hasMap?: any
    /**
     * The type of the thing
     * @type {string}
     * @memberof Place
     */
    type?: string
    /**
     * The name of the thing
     * @type {string}
     * @memberof Place
     */
    name?: string
}
/**
 * A receipt card
 * @export
 * @interface ReceiptCard
 */
export interface ReceiptCard {
    /**
     * Title of the card
     * @type {string}
     * @memberof ReceiptCard
     */
    title?: string
    /**
     * Array of Fact objects
     * @type {Array<Fact>}
     * @memberof ReceiptCard
     */
    facts?: Array<Fact>
    /**
     * Array of Receipt Items
     * @type {Array<ReceiptItem>}
     * @memberof ReceiptCard
     */
    items?: Array<ReceiptItem>
    /**
     * This action will be activated when user taps on the card
     * @type {CardAction}
     * @memberof ReceiptCard
     */
    tap?: CardAction
    /**
     * Total amount of money paid (or to be paid)
     * @type {string}
     * @memberof ReceiptCard
     */
    total?: string
    /**
     * Total amount of tax paid (or to be paid)
     * @type {string}
     * @memberof ReceiptCard
     */
    tax?: string
    /**
     * Total amount of VAT paid (or to be paid)
     * @type {string}
     * @memberof ReceiptCard
     */
    vat?: string
    /**
     * Set of actions applicable to the current card
     * @type {Array<CardAction>}
     * @memberof ReceiptCard
     */
    buttons?: Array<CardAction>
}
/**
 * An item on a receipt card
 * @export
 * @interface ReceiptItem
 */
export interface ReceiptItem {
    /**
     * Title of the Card
     * @type {string}
     * @memberof ReceiptItem
     */
    title?: string
    /**
     * Subtitle appears just below Title field, differs from Title in font styling only
     * @type {string}
     * @memberof ReceiptItem
     */
    subtitle?: string
    /**
     * Text field appears just below subtitle, differs from Subtitle in font styling only
     * @type {string}
     * @memberof ReceiptItem
     */
    text?: string
    /**
     * Image
     * @type {CardImage}
     * @memberof ReceiptItem
     */
    image?: CardImage
    /**
     * Amount with currency
     * @type {string}
     * @memberof ReceiptItem
     */
    price?: string
    /**
     * Number of items of given kind
     * @type {string}
     * @memberof ReceiptItem
     */
    quantity?: string
    /**
     * This action will be activated when user taps on the Item bubble.
     * @type {CardAction}
     * @memberof ReceiptItem
     */
    tap?: CardAction
}
/**
 * A response containing a resource ID
 * @export
 * @interface ResourceResponse
 */
export interface ResourceResponse {
    /**
     * Id of the resource
     * @type {string}
     * @memberof ResourceResponse
     */
    id?: string
}
/**
 * Role of the entity behind the account (Example: User, Bot, etc.)
 * @export
 * @enum {string}
 */
export declare enum RoleTypes {
    User,
    Bot,
}
/**
 * Represents a reference to a programmatic action
 * @export
 * @interface SemanticAction
 */
export interface SemanticAction {
    /**
     * State of this action. Allowed values: `start`, `continue`, `done`
     * @type {SemanticActionStates}
     * @memberof SemanticAction
     */
    state?: SemanticActionStates
    /**
     * ID of this action
     * @type {string}
     * @memberof SemanticAction
     */
    id?: string
    /**
     * Entities associated with this action
     * @type {{ [key: string]: Entity; }}
     * @memberof SemanticAction
     */
    entities?: {
        [key: string]: Entity
    }
}
/**
 * Indicates whether the semantic action is starting, continuing, or done
 * @export
 * @enum {string}
 */
export declare enum SemanticActionStates {
    Start,
    Continue,
    Done,
}
/**
 * A card representing a request to sign in
 * @export
 * @interface SigninCard
 */
export interface SigninCard {
    /**
     * Text for signin request
     * @type {string}
     * @memberof SigninCard
     */
    text?: string
    /**
     * Action to use to perform signin
     * @type {Array<CardAction>}
     * @memberof SigninCard
     */
    buttons?: Array<CardAction>
}
/**
 * SuggestedActions that can be performed
 * @export
 * @interface SuggestedActions
 */
export interface SuggestedActions {
    /**
     * Ids of the recipients that the actions should be shown to.  These Ids are relative to the channelId and a subset of all recipients of the activity
     * @type {Array<string>}
     * @memberof SuggestedActions
     */
    to?: Array<string>
    /**
     * Actions that can be shown to the user
     * @type {Array<CardAction>}
     * @memberof SuggestedActions
     */
    actions?: Array<CardAction>
}
/**
 * Text format types
 * @export
 * @enum {string}
 */
export declare enum TextFormatTypes {
    Markdown,
    Plain,
    Xml,
}
/**
 * Refers to a substring of content within another field
 * @export
 * @interface TextHighlight
 */
export interface TextHighlight {
    /**
     * Defines the snippet of text to highlight
     * @type {string}
     * @memberof TextHighlight
     */
    text?: string
    /**
     * Occurrence of the text field within the referenced text, if multiple exist.
     * @type {number}
     * @memberof TextHighlight
     */
    occurrence?: number
}
/**
 * Thing (entity type: \"https://schema.org/Thing\")
 * @export
 * @interface Thing
 */
export interface Thing {
    /**
     * The type of the thing
     * @type {string}
     * @memberof Thing
     */
    type?: string
    /**
     * The name of the thing
     * @type {string}
     * @memberof Thing
     */
    name?: string
}
/**
 * A thumbnail card (card with a single, small thumbnail image)
 * @export
 * @interface ThumbnailCard
 */
export interface ThumbnailCard {
    /**
     * Title of the card
     * @type {string}
     * @memberof ThumbnailCard
     */
    title?: string
    /**
     * Subtitle of the card
     * @type {string}
     * @memberof ThumbnailCard
     */
    subtitle?: string
    /**
     * Text for the card
     * @type {string}
     * @memberof ThumbnailCard
     */
    text?: string
    /**
     * Array of images for the card
     * @type {Array<CardImage>}
     * @memberof ThumbnailCard
     */
    images?: Array<CardImage>
    /**
     * Set of actions applicable to the current card
     * @type {Array<CardAction>}
     * @memberof ThumbnailCard
     */
    buttons?: Array<CardAction>
    /**
     * This action will be activated when user taps on the card itself
     * @type {CardAction}
     * @memberof ThumbnailCard
     */
    tap?: CardAction
}
/**
 * Thumbnail URL
 * @export
 * @interface ThumbnailUrl
 */
export interface ThumbnailUrl {
    /**
     * URL pointing to the thumbnail to use for media content
     * @type {string}
     * @memberof ThumbnailUrl
     */
    url?: string
    /**
     * HTML alt text to include on this thumbnail image
     * @type {string}
     * @memberof ThumbnailUrl
     */
    alt?: string
}
/**
 * A request to receive a user token
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * The provider to request a user token from
     * @type {string}
     * @memberof TokenRequest
     */
    provider?: string
    /**
     * A collection of settings for the specific provider for this request
     * @type {{ [key: string]: any; }}
     * @memberof TokenRequest
     */
    settings?: {
        [key: string]: any
    }
}
/**
 * A response that includes a user token
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * The channelId of the TokenResponse
     * @type {string}
     * @memberof TokenResponse
     */
    channelId?: string
    /**
     * The connection name
     * @type {string}
     * @memberof TokenResponse
     */
    connectionName?: string
    /**
     * The user token
     * @type {string}
     * @memberof TokenResponse
     */
    token?: string
    /**
     * Expiration for the token, in ISO 8601 format (e.g. \"2007-04-05T14:30Z\")
     * @type {string}
     * @memberof TokenResponse
     */
    expiration?: string
}
/**
 * Transcript
 * @export
 * @interface Transcript
 */
export interface Transcript {
    /**
     * A collection of Activities that conforms to the Transcript schema.
     * @type {Array<Activity>}
     * @memberof Transcript
     */
    activities?: Array<Activity>
}
/**
 * Video card
 * @export
 * @interface VideoCard
 */
export interface VideoCard {
    /**
     * Title of this card
     * @type {string}
     * @memberof VideoCard
     */
    title?: string
    /**
     * Subtitle of this card
     * @type {string}
     * @memberof VideoCard
     */
    subtitle?: string
    /**
     * Text of this card
     * @type {string}
     * @memberof VideoCard
     */
    text?: string
    /**
     * Thumbnail placeholder
     * @type {ThumbnailUrl}
     * @memberof VideoCard
     */
    image?: ThumbnailUrl
    /**
     * Media URLs for this card. When this field contains more than one URL, each URL is an alternative format of the same content.
     * @type {Array<MediaUrl>}
     * @memberof VideoCard
     */
    media?: Array<MediaUrl>
    /**
     * Actions on this card
     * @type {Array<CardAction>}
     * @memberof VideoCard
     */
    buttons?: Array<CardAction>
    /**
     * This content may be shared with others (default:true)
     * @type {boolean}
     * @memberof VideoCard
     */
    shareable?: boolean
    /**
     * Should the client loop playback at end of content (default:true)
     * @type {boolean}
     * @memberof VideoCard
     */
    autoloop?: boolean
    /**
     * Should the client automatically start playback of media in this card (default:true)
     * @type {boolean}
     * @memberof VideoCard
     */
    autostart?: boolean
    /**
     * Aspect ratio of thumbnail/media placeholder. Allowed values are \"16:9\" and \"4:3\"
     * @type {string}
     * @memberof VideoCard
     */
    aspect?: string
    /**
     * Describes the length of the media content without requiring a receiver to open the content. Formatted as an ISO 8601 Duration field.
     * @type {string}
     * @memberof VideoCard
     */
    duration?: string
    /**
     * Supplementary parameter for this card
     * @type {any}
     * @memberof VideoCard
     */
    value?: any
}
/**
 * AttachmentsApi - fetch parameter creator
 * @export
 */
export declare const AttachmentsApiFetchParamCreator: (
    configuration?: Configuration
) => {
    /**
     * Get the named view as binary content
     * @summary GetAttachment
     * @param {string} attachmentId attachment id
     * @param {string} viewId View id from attachmentInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachmentsGetAttachment(
        attachmentId: string,
        viewId: string,
        options?: any
    ): FetchArgs
    /**
     * Get AttachmentInfo structure describing the attachment views
     * @summary GetAttachmentInfo
     * @param {string} attachmentId attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachmentsGetAttachmentInfo(attachmentId: string, options?: any): FetchArgs
}
/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export declare const AttachmentsApiFp: (
    configuration?: Configuration
) => {
    /**
     * Get the named view as binary content
     * @summary GetAttachment
     * @param {string} attachmentId attachment id
     * @param {string} viewId View id from attachmentInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachmentsGetAttachment(
        attachmentId: string,
        viewId: string,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any>
    /**
     * Get AttachmentInfo structure describing the attachment views
     * @summary GetAttachmentInfo
     * @param {string} attachmentId attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachmentsGetAttachmentInfo(
        attachmentId: string,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentInfo>
}
/**
 * AttachmentsApi - factory interface
 * @export
 */
export declare const AttachmentsApiFactory: (
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) => {
    /**
     * Get the named view as binary content
     * @summary GetAttachment
     * @param {string} attachmentId attachment id
     * @param {string} viewId View id from attachmentInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachmentsGetAttachment(
        attachmentId: string,
        viewId: string,
        options?: any
    ): Promise<any>
    /**
     * Get AttachmentInfo structure describing the attachment views
     * @summary GetAttachmentInfo
     * @param {string} attachmentId attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachmentsGetAttachmentInfo(
        attachmentId: string,
        options?: any
    ): Promise<AttachmentInfo>
}
/**
 * AttachmentsApi - interface
 * @export
 * @interface AttachmentsApi
 */
export interface AttachmentsApiInterface {
    /**
     * Get the named view as binary content
     * @summary GetAttachment
     * @param {string} attachmentId attachment id
     * @param {string} viewId View id from attachmentInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApiInterface
     */
    attachmentsGetAttachment(
        attachmentId: string,
        viewId: string,
        options?: any
    ): Promise<any>
    /**
     * Get AttachmentInfo structure describing the attachment views
     * @summary GetAttachmentInfo
     * @param {string} attachmentId attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApiInterface
     */
    attachmentsGetAttachmentInfo(
        attachmentId: string,
        options?: any
    ): Promise<AttachmentInfo>
}
/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export declare class AttachmentsApi extends BaseAPI
    implements AttachmentsApiInterface {
    /**
     * Get the named view as binary content
     * @summary GetAttachment
     * @param {string} attachmentId attachment id
     * @param {string} viewId View id from attachmentInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    attachmentsGetAttachment(
        attachmentId: string,
        viewId: string,
        options?: any
    ): Promise<any>
    /**
     * Get AttachmentInfo structure describing the attachment views
     * @summary GetAttachmentInfo
     * @param {string} attachmentId attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    attachmentsGetAttachmentInfo(
        attachmentId: string,
        options?: any
    ): Promise<AttachmentInfo>
}
/**
 * ConversationsApi - fetch parameter creator
 * @export
 */
export declare const ConversationsApiFetchParamCreator: (
    configuration?: Configuration
) => {
    /**
     * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
     * @summary CreateConversation
     * @param {ConversationParameters} parameters Parameters to create the conversation from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsCreateConversation(
        parameters: ConversationParameters,
        options?: any
    ): FetchArgs
    /**
     * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     * @summary DeleteActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsDeleteActivity(
        conversationId: string,
        activityId: string,
        options?: any
    ): FetchArgs
    /**
     * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
     * @summary DeleteConversationMember
     * @param {string} conversationId Conversation ID
     * @param {string} memberId ID of the member to delete from this conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsDeleteConversationMember(
        conversationId: string,
        memberId: string,
        options?: any
    ): FetchArgs
    /**
     * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     * @summary GetActivityMembers
     * @param {string} conversationId Conversation ID
     * @param {string} activityId Activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetActivityMembers(
        conversationId: string,
        activityId: string,
        options?: any
    ): FetchArgs
    /**
     * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     * @summary GetConversationMembers
     * @param {string} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversationMembers(
        conversationId: string,
        options?: any
    ): FetchArgs
    /**
     * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
     * @summary GetConversationPagedMembers
     * @param {string} conversationId Conversation ID
     * @param {number} [pageSize] Suggested page size
     * @param {string} [continuationToken] Continuation Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversationPagedMembers(
        conversationId: string,
        pageSize?: number,
        continuationToken?: string,
        options?: any
    ): FetchArgs
    /**
     * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
     * @summary GetConversations
     * @param {string} [continuationToken] skip or continuation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversations(
        continuationToken?: string,
        options?: any
    ): FetchArgs
    /**
     * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary ReplyToActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId the reply is to (OPTIONAL)
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsReplyToActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): FetchArgs
    /**
     * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
     * @summary SendConversationHistory
     * @param {string} conversationId Conversation ID
     * @param {Transcript} history Historic activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsSendConversationHistory(
        conversationId: string,
        history: Transcript,
        options?: any
    ): FetchArgs
    /**
     * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary SendToConversation
     * @param {string} conversationId Conversation ID
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsSendToConversation(
        conversationId: string,
        activity: Activity,
        options?: any
    ): FetchArgs
    /**
     * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
     * @summary UpdateActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to update
     * @param {Activity} activity replacement Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsUpdateActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): FetchArgs
    /**
     * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     * @summary UploadAttachment
     * @param {string} conversationId Conversation ID
     * @param {AttachmentData} attachmentUpload Attachment data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsUploadAttachment(
        conversationId: string,
        attachmentUpload: AttachmentData,
        options?: any
    ): FetchArgs
}
/**
 * ConversationsApi - functional programming interface
 * @export
 */
export declare const ConversationsApiFp: (
    configuration?: Configuration
) => {
    /**
     * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
     * @summary CreateConversation
     * @param {ConversationParameters} parameters Parameters to create the conversation from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsCreateConversation(
        parameters: ConversationParameters,
        options?: any
    ): (
        fetch?: FetchAPI,
        basePath?: string
    ) => Promise<ConversationResourceResponse>
    /**
     * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     * @summary DeleteActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsDeleteActivity(
        conversationId: string,
        activityId: string,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response>
    /**
     * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
     * @summary DeleteConversationMember
     * @param {string} conversationId Conversation ID
     * @param {string} memberId ID of the member to delete from this conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsDeleteConversationMember(
        conversationId: string,
        memberId: string,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response>
    /**
     * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     * @summary GetActivityMembers
     * @param {string} conversationId Conversation ID
     * @param {string} activityId Activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetActivityMembers(
        conversationId: string,
        activityId: string,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChannelAccount[]>
    /**
     * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     * @summary GetConversationMembers
     * @param {string} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversationMembers(
        conversationId: string,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChannelAccount[]>
    /**
     * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
     * @summary GetConversationPagedMembers
     * @param {string} conversationId Conversation ID
     * @param {number} [pageSize] Suggested page size
     * @param {string} [continuationToken] Continuation Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversationPagedMembers(
        conversationId: string,
        pageSize?: number,
        continuationToken?: string,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PagedMembersResult>
    /**
     * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
     * @summary GetConversations
     * @param {string} [continuationToken] skip or continuation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversations(
        continuationToken?: string,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ConversationsResult>
    /**
     * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary ReplyToActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId the reply is to (OPTIONAL)
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsReplyToActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResourceResponse>
    /**
     * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
     * @summary SendConversationHistory
     * @param {string} conversationId Conversation ID
     * @param {Transcript} history Historic activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsSendConversationHistory(
        conversationId: string,
        history: Transcript,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResourceResponse>
    /**
     * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary SendToConversation
     * @param {string} conversationId Conversation ID
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsSendToConversation(
        conversationId: string,
        activity: Activity,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResourceResponse>
    /**
     * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
     * @summary UpdateActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to update
     * @param {Activity} activity replacement Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsUpdateActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResourceResponse>
    /**
     * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     * @summary UploadAttachment
     * @param {string} conversationId Conversation ID
     * @param {AttachmentData} attachmentUpload Attachment data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsUploadAttachment(
        conversationId: string,
        attachmentUpload: AttachmentData,
        options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResourceResponse>
}
/**
 * ConversationsApi - factory interface
 * @export
 */
export declare const ConversationsApiFactory: (
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) => {
    /**
     * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
     * @summary CreateConversation
     * @param {ConversationParameters} parameters Parameters to create the conversation from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsCreateConversation(
        parameters: ConversationParameters,
        options?: any
    ): Promise<ConversationResourceResponse>
    /**
     * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     * @summary DeleteActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsDeleteActivity(
        conversationId: string,
        activityId: string,
        options?: any
    ): Promise<Response>
    /**
     * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
     * @summary DeleteConversationMember
     * @param {string} conversationId Conversation ID
     * @param {string} memberId ID of the member to delete from this conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsDeleteConversationMember(
        conversationId: string,
        memberId: string,
        options?: any
    ): Promise<Response>
    /**
     * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     * @summary GetActivityMembers
     * @param {string} conversationId Conversation ID
     * @param {string} activityId Activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetActivityMembers(
        conversationId: string,
        activityId: string,
        options?: any
    ): Promise<ChannelAccount[]>
    /**
     * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     * @summary GetConversationMembers
     * @param {string} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversationMembers(
        conversationId: string,
        options?: any
    ): Promise<ChannelAccount[]>
    /**
     * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
     * @summary GetConversationPagedMembers
     * @param {string} conversationId Conversation ID
     * @param {number} [pageSize] Suggested page size
     * @param {string} [continuationToken] Continuation Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversationPagedMembers(
        conversationId: string,
        pageSize?: number,
        continuationToken?: string,
        options?: any
    ): Promise<PagedMembersResult>
    /**
     * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
     * @summary GetConversations
     * @param {string} [continuationToken] skip or continuation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsGetConversations(
        continuationToken?: string,
        options?: any
    ): Promise<ConversationsResult>
    /**
     * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary ReplyToActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId the reply is to (OPTIONAL)
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsReplyToActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
     * @summary SendConversationHistory
     * @param {string} conversationId Conversation ID
     * @param {Transcript} history Historic activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsSendConversationHistory(
        conversationId: string,
        history: Transcript,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary SendToConversation
     * @param {string} conversationId Conversation ID
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsSendToConversation(
        conversationId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
     * @summary UpdateActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to update
     * @param {Activity} activity replacement Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsUpdateActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     * @summary UploadAttachment
     * @param {string} conversationId Conversation ID
     * @param {AttachmentData} attachmentUpload Attachment data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationsUploadAttachment(
        conversationId: string,
        attachmentUpload: AttachmentData,
        options?: any
    ): Promise<ResourceResponse>
}
/**
 * ConversationsApi - interface
 * @export
 * @interface ConversationsApi
 */
export interface ConversationsApiInterface {
    /**
     * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
     * @summary CreateConversation
     * @param {ConversationParameters} parameters Parameters to create the conversation from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsCreateConversation(
        parameters: ConversationParameters,
        options?: any
    ): Promise<ConversationResourceResponse>
    /**
     * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     * @summary DeleteActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsDeleteActivity(
        conversationId: string,
        activityId: string,
        options?: any
    ): Promise<{}>
    /**
     * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
     * @summary DeleteConversationMember
     * @param {string} conversationId Conversation ID
     * @param {string} memberId ID of the member to delete from this conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsDeleteConversationMember(
        conversationId: string,
        memberId: string,
        options?: any
    ): Promise<{}>
    /**
     * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     * @summary GetActivityMembers
     * @param {string} conversationId Conversation ID
     * @param {string} activityId Activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsGetActivityMembers(
        conversationId: string,
        activityId: string,
        options?: any
    ): Promise<Array<ChannelAccount>>
    /**
     * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     * @summary GetConversationMembers
     * @param {string} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsGetConversationMembers(
        conversationId: string,
        options?: any
    ): Promise<Array<ChannelAccount>>
    /**
     * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
     * @summary GetConversationPagedMembers
     * @param {string} conversationId Conversation ID
     * @param {number} [pageSize] Suggested page size
     * @param {string} [continuationToken] Continuation Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsGetConversationPagedMembers(
        conversationId: string,
        pageSize?: number,
        continuationToken?: string,
        options?: any
    ): Promise<PagedMembersResult>
    /**
     * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
     * @summary GetConversations
     * @param {string} [continuationToken] skip or continuation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsGetConversations(
        continuationToken?: string,
        options?: any
    ): Promise<ConversationsResult>
    /**
     * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary ReplyToActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId the reply is to (OPTIONAL)
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsReplyToActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
     * @summary SendConversationHistory
     * @param {string} conversationId Conversation ID
     * @param {Transcript} history Historic activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsSendConversationHistory(
        conversationId: string,
        history: Transcript,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary SendToConversation
     * @param {string} conversationId Conversation ID
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsSendToConversation(
        conversationId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
     * @summary UpdateActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to update
     * @param {Activity} activity replacement Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsUpdateActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     * @summary UploadAttachment
     * @param {string} conversationId Conversation ID
     * @param {AttachmentData} attachmentUpload Attachment data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiInterface
     */
    conversationsUploadAttachment(
        conversationId: string,
        attachmentUpload: AttachmentData,
        options?: any
    ): Promise<ResourceResponse>
}
/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export declare class ConversationsApi extends BaseAPI
    implements ConversationsApiInterface {
    /**
     * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
     * @summary CreateConversation
     * @param {ConversationParameters} parameters Parameters to create the conversation from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsCreateConversation(
        parameters: ConversationParameters,
        options?: any
    ): Promise<ConversationResourceResponse>
    /**
     * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     * @summary DeleteActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsDeleteActivity(
        conversationId: string,
        activityId: string,
        options?: any
    ): Promise<Response>
    /**
     * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
     * @summary DeleteConversationMember
     * @param {string} conversationId Conversation ID
     * @param {string} memberId ID of the member to delete from this conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsDeleteConversationMember(
        conversationId: string,
        memberId: string,
        options?: any
    ): Promise<Response>
    /**
     * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     * @summary GetActivityMembers
     * @param {string} conversationId Conversation ID
     * @param {string} activityId Activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetActivityMembers(
        conversationId: string,
        activityId: string,
        options?: any
    ): Promise<ChannelAccount[]>
    /**
     * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     * @summary GetConversationMembers
     * @param {string} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversationMembers(
        conversationId: string,
        options?: any
    ): Promise<ChannelAccount[]>
    /**
     * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
     * @summary GetConversationPagedMembers
     * @param {string} conversationId Conversation ID
     * @param {number} [pageSize] Suggested page size
     * @param {string} [continuationToken] Continuation Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversationPagedMembers(
        conversationId: string,
        pageSize?: number,
        continuationToken?: string,
        options?: any
    ): Promise<PagedMembersResult>
    /**
     * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
     * @summary GetConversations
     * @param {string} [continuationToken] skip or continuation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversations(
        continuationToken?: string,
        options?: any
    ): Promise<ConversationsResult>
    /**
     * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary ReplyToActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId the reply is to (OPTIONAL)
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsReplyToActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
     * @summary SendConversationHistory
     * @param {string} conversationId Conversation ID
     * @param {Transcript} history Historic activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsSendConversationHistory(
        conversationId: string,
        history: Transcript,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary SendToConversation
     * @param {string} conversationId Conversation ID
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsSendToConversation(
        conversationId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
     * @summary UpdateActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to update
     * @param {Activity} activity replacement Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsUpdateActivity(
        conversationId: string,
        activityId: string,
        activity: Activity,
        options?: any
    ): Promise<ResourceResponse>
    /**
     * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     * @summary UploadAttachment
     * @param {string} conversationId Conversation ID
     * @param {AttachmentData} attachmentUpload Attachment data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsUploadAttachment(
        conversationId: string,
        attachmentUpload: AttachmentData,
        options?: any
    ): Promise<ResourceResponse>
}
