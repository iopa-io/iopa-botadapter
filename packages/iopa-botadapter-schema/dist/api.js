'use strict'
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Microsoft Bot Connector API - v3.0
 * The Bot Connector REST API allows your bot to send and receive messages to channels configured in the  [Bot Framework Developer Portal](https://dev.botframework.com). The Connector service uses industry-standard REST  and JSON over HTTPS.    Client libraries for this REST API are available. See below for a list.    Many bots will use both the Bot Connector REST API and the associated [Bot State REST API](/en-us/restapi/state). The  Bot State REST API allows a bot to store and retrieve state associated with users and conversations.    Authentication for both the Bot Connector and Bot State REST APIs is accomplished with JWT Bearer tokens, and is  described in detail in the [Connector Authentication](/en-us/restapi/authentication) document.    # Client Libraries for the Bot Connector REST API    * [Bot Builder for C#](/en-us/csharp/builder/sdkreference/)  * [Bot Builder for Node.js](/en-us/node/builder/overview/)  * Generate your own from the [Connector API Swagger file](https://raw.githubusercontent.com/Microsoft/BotBuilder/master/CSharp/Library/Microsoft.Bot.Connector.Shared/Swagger/ConnectorAPI.json)    Â© 2016 Microsoft
 *
 * OpenAPI spec version: v3
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, '__esModule', { value: true })
const url = require('url')
const portableFetch = require('portable-fetch')
const BASE_PATH = 'https://api.botframework.com'.replace(/\/+$/, '')
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
}
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath
        this.fetch = fetch
        if (configuration) {
            this.configuration = configuration
            this.basePath = configuration.basePath || this.basePath
        }
    }
}
exports.BaseAPI = BaseAPI
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg)
        this.field = field
    }
}
exports.RequiredError = RequiredError
/**
 * Defines action types for clickable buttons.
 * @export
 * @enum {string}
 */
var ActionTypes
;(function(ActionTypes) {
    ActionTypes[(ActionTypes['OpenUrl'] = 'openUrl')] = 'OpenUrl'
    ActionTypes[(ActionTypes['ImBack'] = 'imBack')] = 'ImBack'
    ActionTypes[(ActionTypes['PostBack'] = 'postBack')] = 'PostBack'
    ActionTypes[(ActionTypes['PlayAudio'] = 'playAudio')] = 'PlayAudio'
    ActionTypes[(ActionTypes['PlayVideo'] = 'playVideo')] = 'PlayVideo'
    ActionTypes[(ActionTypes['ShowImage'] = 'showImage')] = 'ShowImage'
    ActionTypes[(ActionTypes['DownloadFile'] = 'downloadFile')] = 'DownloadFile'
    ActionTypes[(ActionTypes['Signin'] = 'signin')] = 'Signin'
    ActionTypes[(ActionTypes['Call'] = 'call')] = 'Call'
    ActionTypes[(ActionTypes['Payment'] = 'payment')] = 'Payment'
    ActionTypes[(ActionTypes['MessageBack'] = 'messageBack')] = 'MessageBack'
})((ActionTypes = exports.ActionTypes || (exports.ActionTypes = {})))
/**
 * Defines the importance of an Activity
 * @export
 * @enum {string}
 */
var ActivityImportance
;(function(ActivityImportance) {
    ActivityImportance[(ActivityImportance['Low'] = 'low')] = 'Low'
    ActivityImportance[(ActivityImportance['Normal'] = 'normal')] = 'Normal'
    ActivityImportance[(ActivityImportance['High'] = 'high')] = 'High'
})(
    (ActivityImportance =
        exports.ActivityImportance || (exports.ActivityImportance = {}))
)
/**
 * Types of Activities
 * @export
 * @enum {string}
 */
var ActivityTypes
;(function(ActivityTypes) {
    ActivityTypes[(ActivityTypes['Message'] = 'message')] = 'Message'
    ActivityTypes[
        (ActivityTypes['ContactRelationUpdate'] = 'contactRelationUpdate')
    ] = 'ContactRelationUpdate'
    ActivityTypes[
        (ActivityTypes['ConversationUpdate'] = 'conversationUpdate')
    ] = 'ConversationUpdate'
    ActivityTypes[(ActivityTypes['Typing'] = 'typing')] = 'Typing'
    ActivityTypes[(ActivityTypes['EndOfConversation'] = 'endOfConversation')] =
        'EndOfConversation'
    ActivityTypes[(ActivityTypes['Event'] = 'event')] = 'Event'
    ActivityTypes[(ActivityTypes['Invoke'] = 'invoke')] = 'Invoke'
    ActivityTypes[(ActivityTypes['DeleteUserData'] = 'deleteUserData')] =
        'DeleteUserData'
    ActivityTypes[(ActivityTypes['MessageUpdate'] = 'messageUpdate')] =
        'MessageUpdate'
    ActivityTypes[(ActivityTypes['MessageDelete'] = 'messageDelete')] =
        'MessageDelete'
    ActivityTypes[
        (ActivityTypes['InstallationUpdate'] = 'installationUpdate')
    ] = 'InstallationUpdate'
    ActivityTypes[(ActivityTypes['MessageReaction'] = 'messageReaction')] =
        'MessageReaction'
    ActivityTypes[(ActivityTypes['Suggestion'] = 'suggestion')] = 'Suggestion'
    ActivityTypes[(ActivityTypes['Trace'] = 'trace')] = 'Trace'
    ActivityTypes[(ActivityTypes['Handoff'] = 'handoff')] = 'Handoff'
    // additions
    ActivityTypes[(ActivityTypes['Call'] = 'call')] = 'Call'
    ActivityTypes[(ActivityTypes['MessageStatus'] = 'messageStatus')] =
        'MessageStatus'
    ActivityTypes[(ActivityTypes['CallStatus'] = 'callStatus')] = 'CallStatus'
})((ActivityTypes = exports.ActivityTypes || (exports.ActivityTypes = {})))
/**
 * Attachment layout types
 * @export
 * @enum {string}
 */
var AttachmentLayoutTypes
;(function(AttachmentLayoutTypes) {
    AttachmentLayoutTypes[(AttachmentLayoutTypes['List'] = 'list')] = 'List'
    AttachmentLayoutTypes[(AttachmentLayoutTypes['Carousel'] = 'carousel')] =
        'Carousel'
})(
    (AttachmentLayoutTypes =
        exports.AttachmentLayoutTypes || (exports.AttachmentLayoutTypes = {}))
)
/**
 * Action types valid for ContactRelationUpdate activities
 * @export
 * @enum {string}
 */
var ContactRelationUpdateActionTypes
;(function(ContactRelationUpdateActionTypes) {
    ContactRelationUpdateActionTypes[
        (ContactRelationUpdateActionTypes['Add'] = 'add')
    ] = 'Add'
    ContactRelationUpdateActionTypes[
        (ContactRelationUpdateActionTypes['Remove'] = 'remove')
    ] = 'Remove'
})(
    (ContactRelationUpdateActionTypes =
        exports.ContactRelationUpdateActionTypes ||
        (exports.ContactRelationUpdateActionTypes = {}))
)
/**
 * Values for deliveryMode field
 * @export
 * @enum {string}
 */
var DeliveryModes
;(function(DeliveryModes) {
    DeliveryModes[(DeliveryModes['Normal'] = 'normal')] = 'Normal'
    DeliveryModes[(DeliveryModes['Notification'] = 'notification')] =
        'Notification'
})((DeliveryModes = exports.DeliveryModes || (exports.DeliveryModes = {})))
/**
 * Codes indicating why a conversation has ended
 * @export
 * @enum {string}
 */
var EndOfConversationCodes
;(function(EndOfConversationCodes) {
    EndOfConversationCodes[(EndOfConversationCodes['Unknown'] = 'unknown')] =
        'Unknown'
    EndOfConversationCodes[
        (EndOfConversationCodes['CompletedSuccessfully'] =
            'completedSuccessfully')
    ] = 'CompletedSuccessfully'
    EndOfConversationCodes[
        (EndOfConversationCodes['UserCancelled'] = 'userCancelled')
    ] = 'UserCancelled'
    EndOfConversationCodes[
        (EndOfConversationCodes['BotTimedOut'] = 'botTimedOut')
    ] = 'BotTimedOut'
    EndOfConversationCodes[
        (EndOfConversationCodes['BotIssuedInvalidMessage'] =
            'botIssuedInvalidMessage')
    ] = 'BotIssuedInvalidMessage'
    EndOfConversationCodes[
        (EndOfConversationCodes['ChannelFailed'] = 'channelFailed')
    ] = 'ChannelFailed'
})(
    (EndOfConversationCodes =
        exports.EndOfConversationCodes || (exports.EndOfConversationCodes = {}))
)
/**
 * Indicates whether the bot is accepting, expecting, or ignoring input
 * @export
 * @enum {string}
 */
var InputHints
;(function(InputHints) {
    InputHints[(InputHints['AcceptingInput'] = 'acceptingInput')] =
        'AcceptingInput'
    InputHints[(InputHints['IgnoringInput'] = 'ignoringInput')] =
        'IgnoringInput'
    InputHints[(InputHints['ExpectingInput'] = 'expectingInput')] =
        'ExpectingInput'
})((InputHints = exports.InputHints || (exports.InputHints = {})))
/**
 * Action types valid for InstallationUpdate activities
 * @export
 * @enum {string}
 */
var InstallationUpdateActionTypes
;(function(InstallationUpdateActionTypes) {
    InstallationUpdateActionTypes[
        (InstallationUpdateActionTypes['Add'] = 'add')
    ] = 'Add'
    InstallationUpdateActionTypes[
        (InstallationUpdateActionTypes['Remove'] = 'remove')
    ] = 'Remove'
})(
    (InstallationUpdateActionTypes =
        exports.InstallationUpdateActionTypes ||
        (exports.InstallationUpdateActionTypes = {}))
)
/**
 * Message reaction types
 * @export
 * @enum {string}
 */
var MessageReactionTypes
;(function(MessageReactionTypes) {
    MessageReactionTypes[(MessageReactionTypes['Like'] = 'like')] = 'Like'
    MessageReactionTypes[(MessageReactionTypes['PlusOne'] = 'plusOne')] =
        'PlusOne'
})(
    (MessageReactionTypes =
        exports.MessageReactionTypes || (exports.MessageReactionTypes = {}))
)
/**
 * Role of the entity behind the account (Example: User, Bot, etc.)
 * @export
 * @enum {string}
 */
var RoleTypes
;(function(RoleTypes) {
    RoleTypes[(RoleTypes['User'] = 'user')] = 'User'
    RoleTypes[(RoleTypes['Bot'] = 'bot')] = 'Bot'
})((RoleTypes = exports.RoleTypes || (exports.RoleTypes = {})))
/**
 * Indicates whether the semantic action is starting, continuing, or done
 * @export
 * @enum {string}
 */
var SemanticActionStates
;(function(SemanticActionStates) {
    SemanticActionStates[(SemanticActionStates['Start'] = 'start')] = 'Start'
    SemanticActionStates[(SemanticActionStates['Continue'] = 'continue')] =
        'Continue'
    SemanticActionStates[(SemanticActionStates['Done'] = 'done')] = 'Done'
})(
    (SemanticActionStates =
        exports.SemanticActionStates || (exports.SemanticActionStates = {}))
)
/**
 * Text format types
 * @export
 * @enum {string}
 */
var TextFormatTypes
;(function(TextFormatTypes) {
    TextFormatTypes[(TextFormatTypes['Markdown'] = 'markdown')] = 'Markdown'
    TextFormatTypes[(TextFormatTypes['Plain'] = 'plain')] = 'Plain'
    TextFormatTypes[(TextFormatTypes['Xml'] = 'xml')] = 'Xml'
})(
    (TextFormatTypes =
        exports.TextFormatTypes || (exports.TextFormatTypes = {}))
)
/**
 * AttachmentsApi - fetch parameter creator
 * @export
 */
exports.AttachmentsApiFetchParamCreator = function(configuration) {
    return {
        /**
         * Get the named view as binary content
         * @summary GetAttachment
         * @param {string} attachmentId attachment id
         * @param {string} viewId View id from attachmentInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachment(attachmentId, viewId, options = {}) {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling attachmentsGetAttachment.'
                )
            }
            // verify required parameter 'viewId' is not null or undefined
            if (viewId === null || viewId === undefined) {
                throw new RequiredError(
                    'viewId',
                    'Required parameter viewId was null or undefined when calling attachmentsGetAttachment.'
                )
            }
            const localVarPath = `/v3/attachments/{attachmentId}/views/{viewId}`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(attachmentId))
                )
                .replace(`{${'viewId'}}`, encodeURIComponent(String(viewId)))
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Get AttachmentInfo structure describing the attachment views
         * @summary GetAttachmentInfo
         * @param {string} attachmentId attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachmentInfo(attachmentId, options = {}) {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling attachmentsGetAttachmentInfo.'
                )
            }
            const localVarPath = `/v3/attachments/{attachmentId}`.replace(
                `{${'attachmentId'}}`,
                encodeURIComponent(String(attachmentId))
            )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}
/**
 * AttachmentsApi - functional programming interface
 * @export
 */
exports.AttachmentsApiFp = function(configuration) {
    return {
        /**
         * Get the named view as binary content
         * @summary GetAttachment
         * @param {string} attachmentId attachment id
         * @param {string} viewId View id from attachmentInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachment(attachmentId, viewId, options) {
            const localVarFetchArgs = exports
                .AttachmentsApiFetchParamCreator(configuration)
                .attachmentsGetAttachment(attachmentId, viewId, options)
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * Get AttachmentInfo structure describing the attachment views
         * @summary GetAttachmentInfo
         * @param {string} attachmentId attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachmentInfo(attachmentId, options) {
            const localVarFetchArgs = exports
                .AttachmentsApiFetchParamCreator(configuration)
                .attachmentsGetAttachmentInfo(attachmentId, options)
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
    }
}
/**
 * AttachmentsApi - factory interface
 * @export
 */
exports.AttachmentsApiFactory = function(configuration, fetch, basePath) {
    return {
        /**
         * Get the named view as binary content
         * @summary GetAttachment
         * @param {string} attachmentId attachment id
         * @param {string} viewId View id from attachmentInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachment(attachmentId, viewId, options) {
            return exports
                .AttachmentsApiFp(configuration)
                .attachmentsGetAttachment(
                    attachmentId,
                    viewId,
                    options
                )(fetch, basePath)
        },
        /**
         * Get AttachmentInfo structure describing the attachment views
         * @summary GetAttachmentInfo
         * @param {string} attachmentId attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachmentInfo(attachmentId, options) {
            return exports
                .AttachmentsApiFp(configuration)
                .attachmentsGetAttachmentInfo(attachmentId, options)(
                fetch,
                basePath
            )
        },
    }
}
/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
class AttachmentsApi extends BaseAPI {
    /**
     * Get the named view as binary content
     * @summary GetAttachment
     * @param {string} attachmentId attachment id
     * @param {string} viewId View id from attachmentInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    attachmentsGetAttachment(attachmentId, viewId, options) {
        return exports
            .AttachmentsApiFp(this.configuration)
            .attachmentsGetAttachment(
                attachmentId,
                viewId,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * Get AttachmentInfo structure describing the attachment views
     * @summary GetAttachmentInfo
     * @param {string} attachmentId attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    attachmentsGetAttachmentInfo(attachmentId, options) {
        return exports
            .AttachmentsApiFp(this.configuration)
            .attachmentsGetAttachmentInfo(attachmentId, options)(
            this.fetch,
            this.basePath
        )
    }
}
exports.AttachmentsApi = AttachmentsApi
/**
 * ConversationsApi - fetch parameter creator
 * @export
 */
exports.ConversationsApiFetchParamCreator = function(configuration) {
    return {
        /**
         * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
         * @summary CreateConversation
         * @param {ConversationParameters} parameters Parameters to create the conversation from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsCreateConversation(parameters, options = {}) {
            // verify required parameter 'parameters' is not null or undefined
            if (parameters === null || parameters === undefined) {
                throw new RequiredError(
                    'parameters',
                    'Required parameter parameters was null or undefined when calling conversationsCreateConversation.'
                )
            }
            const localVarPath = `/v3/conversations`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarHeaderParameter['Content-Type'] = 'application/json'
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            const needsSerialization =
                'ConversationParameters' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json'
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(parameters || {})
                : parameters || ''
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
         * @summary DeleteActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteActivity(conversationId, activityId, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsDeleteActivity.'
                )
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError(
                    'activityId',
                    'Required parameter activityId was null or undefined when calling conversationsDeleteActivity.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/{activityId}`
                .replace(
                    `{${'conversationId'}}`,
                    encodeURIComponent(String(conversationId))
                )
                .replace(
                    `{${'activityId'}}`,
                    encodeURIComponent(String(activityId))
                )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
         * @summary DeleteConversationMember
         * @param {string} conversationId Conversation ID
         * @param {string} memberId ID of the member to delete from this conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteConversationMember(
            conversationId,
            memberId,
            options = {}
        ) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsDeleteConversationMember.'
                )
            }
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError(
                    'memberId',
                    'Required parameter memberId was null or undefined when calling conversationsDeleteConversationMember.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/members/{memberId}`
                .replace(
                    `{${'conversationId'}}`,
                    encodeURIComponent(String(conversationId))
                )
                .replace(
                    `{${'memberId'}}`,
                    encodeURIComponent(String(memberId))
                )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
         * @summary GetActivityMembers
         * @param {string} conversationId Conversation ID
         * @param {string} activityId Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetActivityMembers(
            conversationId,
            activityId,
            options = {}
        ) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsGetActivityMembers.'
                )
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError(
                    'activityId',
                    'Required parameter activityId was null or undefined when calling conversationsGetActivityMembers.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/{activityId}/members`
                .replace(
                    `{${'conversationId'}}`,
                    encodeURIComponent(String(conversationId))
                )
                .replace(
                    `{${'activityId'}}`,
                    encodeURIComponent(String(activityId))
                )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
         * @summary GetConversationMembers
         * @param {string} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationMembers(conversationId, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsGetConversationMembers.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/members`.replace(
                `{${'conversationId'}}`,
                encodeURIComponent(String(conversationId))
            )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
         * @summary GetConversationPagedMembers
         * @param {string} conversationId Conversation ID
         * @param {number} [pageSize] Suggested page size
         * @param {string} [continuationToken] Continuation Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationPagedMembers(
            conversationId,
            pageSize,
            continuationToken,
            options = {}
        ) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsGetConversationPagedMembers.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/pagedmembers`.replace(
                `{${'conversationId'}}`,
                encodeURIComponent(String(conversationId))
            )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize
            }
            if (continuationToken !== undefined) {
                localVarQueryParameter['continuationToken'] = continuationToken
            }
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
         * @summary GetConversations
         * @param {string} [continuationToken] skip or continuation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversations(continuationToken, options = {}) {
            const localVarPath = `/v3/conversations`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            if (continuationToken !== undefined) {
                localVarQueryParameter['continuationToken'] = continuationToken
            }
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary ReplyToActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId the reply is to (OPTIONAL)
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsReplyToActivity(
            conversationId,
            activityId,
            activity,
            options = {}
        ) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsReplyToActivity.'
                )
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError(
                    'activityId',
                    'Required parameter activityId was null or undefined when calling conversationsReplyToActivity.'
                )
            }
            // verify required parameter 'activity' is not null or undefined
            if (activity === null || activity === undefined) {
                throw new RequiredError(
                    'activity',
                    'Required parameter activity was null or undefined when calling conversationsReplyToActivity.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/{activityId}`
                .replace(
                    `{${'conversationId'}}`,
                    encodeURIComponent(String(conversationId))
                )
                .replace(
                    `{${'activityId'}}`,
                    encodeURIComponent(String(activityId))
                )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarHeaderParameter['Content-Type'] = 'application/json'
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            const needsSerialization =
                'Activity' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json'
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(activity || {})
                : activity || ''
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
         * @summary SendConversationHistory
         * @param {string} conversationId Conversation ID
         * @param {Transcript} history Historic activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendConversationHistory(
            conversationId,
            history,
            options = {}
        ) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsSendConversationHistory.'
                )
            }
            // verify required parameter 'history' is not null or undefined
            if (history === null || history === undefined) {
                throw new RequiredError(
                    'history',
                    'Required parameter history was null or undefined when calling conversationsSendConversationHistory.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/history`.replace(
                `{${'conversationId'}}`,
                encodeURIComponent(String(conversationId))
            )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarHeaderParameter['Content-Type'] = 'application/json'
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            const needsSerialization =
                'Transcript' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json'
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(history || {})
                : history || ''
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary SendToConversation
         * @param {string} conversationId Conversation ID
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendToConversation(
            conversationId,
            activity,
            options = {}
        ) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsSendToConversation.'
                )
            }
            // verify required parameter 'activity' is not null or undefined
            if (activity === null || activity === undefined) {
                throw new RequiredError(
                    'activity',
                    'Required parameter activity was null or undefined when calling conversationsSendToConversation.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities`.replace(
                `{${'conversationId'}}`,
                encodeURIComponent(String(conversationId))
            )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarHeaderParameter['Content-Type'] = 'application/json'
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            const needsSerialization =
                'Activity' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json'
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(activity || {})
                : activity || ''
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
         * @summary UpdateActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to update
         * @param {Activity} activity replacement Activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUpdateActivity(
            conversationId,
            activityId,
            activity,
            options = {}
        ) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsUpdateActivity.'
                )
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError(
                    'activityId',
                    'Required parameter activityId was null or undefined when calling conversationsUpdateActivity.'
                )
            }
            // verify required parameter 'activity' is not null or undefined
            if (activity === null || activity === undefined) {
                throw new RequiredError(
                    'activity',
                    'Required parameter activity was null or undefined when calling conversationsUpdateActivity.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/{activityId}`
                .replace(
                    `{${'conversationId'}}`,
                    encodeURIComponent(String(conversationId))
                )
                .replace(
                    `{${'activityId'}}`,
                    encodeURIComponent(String(activityId))
                )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarHeaderParameter['Content-Type'] = 'application/json'
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            const needsSerialization =
                'Activity' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json'
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(activity || {})
                : activity || ''
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
         * @summary UploadAttachment
         * @param {string} conversationId Conversation ID
         * @param {AttachmentData} attachmentUpload Attachment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUploadAttachment(
            conversationId,
            attachmentUpload,
            options = {}
        ) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError(
                    'conversationId',
                    'Required parameter conversationId was null or undefined when calling conversationsUploadAttachment.'
                )
            }
            // verify required parameter 'attachmentUpload' is not null or undefined
            if (attachmentUpload === null || attachmentUpload === undefined) {
                throw new RequiredError(
                    'attachmentUpload',
                    'Required parameter attachmentUpload was null or undefined when calling conversationsUploadAttachment.'
                )
            }
            const localVarPath = `/v3/conversations/{conversationId}/attachments`.replace(
                `{${'conversationId'}}`,
                encodeURIComponent(String(conversationId))
            )
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            )
            const localVarHeaderParameter = {}
            const localVarQueryParameter = {}
            localVarHeaderParameter['Content-Type'] = 'application/json'
            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )
            const needsSerialization =
                'AttachmentData' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json'
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(attachmentUpload || {})
                : attachmentUpload || ''
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}
/**
 * ConversationsApi - functional programming interface
 * @export
 */
exports.ConversationsApiFp = function(configuration) {
    return {
        /**
         * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
         * @summary CreateConversation
         * @param {ConversationParameters} parameters Parameters to create the conversation from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsCreateConversation(parameters, options) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsCreateConversation(parameters, options)
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
         * @summary DeleteActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteActivity(conversationId, activityId, options) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsDeleteActivity(
                    conversationId,
                    activityId,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
         * @summary DeleteConversationMember
         * @param {string} conversationId Conversation ID
         * @param {string} memberId ID of the member to delete from this conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteConversationMember(
            conversationId,
            memberId,
            options
        ) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsDeleteConversationMember(
                    conversationId,
                    memberId,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
         * @summary GetActivityMembers
         * @param {string} conversationId Conversation ID
         * @param {string} activityId Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetActivityMembers(conversationId, activityId, options) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsGetActivityMembers(
                    conversationId,
                    activityId,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
         * @summary GetConversationMembers
         * @param {string} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationMembers(conversationId, options) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsGetConversationMembers(conversationId, options)
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
         * @summary GetConversationPagedMembers
         * @param {string} conversationId Conversation ID
         * @param {number} [pageSize] Suggested page size
         * @param {string} [continuationToken] Continuation Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationPagedMembers(
            conversationId,
            pageSize,
            continuationToken,
            options
        ) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsGetConversationPagedMembers(
                    conversationId,
                    pageSize,
                    continuationToken,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
         * @summary GetConversations
         * @param {string} [continuationToken] skip or continuation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversations(continuationToken, options) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsGetConversations(continuationToken, options)
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary ReplyToActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId the reply is to (OPTIONAL)
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsReplyToActivity(
            conversationId,
            activityId,
            activity,
            options
        ) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsReplyToActivity(
                    conversationId,
                    activityId,
                    activity,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
         * @summary SendConversationHistory
         * @param {string} conversationId Conversation ID
         * @param {Transcript} history Historic activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendConversationHistory(conversationId, history, options) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsSendConversationHistory(
                    conversationId,
                    history,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary SendToConversation
         * @param {string} conversationId Conversation ID
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendToConversation(conversationId, activity, options) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsSendToConversation(
                    conversationId,
                    activity,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
         * @summary UpdateActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to update
         * @param {Activity} activity replacement Activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUpdateActivity(
            conversationId,
            activityId,
            activity,
            options
        ) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsUpdateActivity(
                    conversationId,
                    activityId,
                    activity,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
        /**
         * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
         * @summary UploadAttachment
         * @param {string} conversationId Conversation ID
         * @param {AttachmentData} attachmentUpload Attachment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUploadAttachment(
            conversationId,
            attachmentUpload,
            options
        ) {
            const localVarFetchArgs = exports
                .ConversationsApiFetchParamCreator(configuration)
                .conversationsUploadAttachment(
                    conversationId,
                    attachmentUpload,
                    options
                )
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json()
                    } else {
                        throw response
                    }
                })
            }
        },
    }
}
/**
 * ConversationsApi - factory interface
 * @export
 */
exports.ConversationsApiFactory = function(configuration, fetch, basePath) {
    return {
        /**
         * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
         * @summary CreateConversation
         * @param {ConversationParameters} parameters Parameters to create the conversation from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsCreateConversation(parameters, options) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsCreateConversation(parameters, options)(
                fetch,
                basePath
            )
        },
        /**
         * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
         * @summary DeleteActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteActivity(conversationId, activityId, options) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsDeleteActivity(
                    conversationId,
                    activityId,
                    options
                )(fetch, basePath)
        },
        /**
         * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
         * @summary DeleteConversationMember
         * @param {string} conversationId Conversation ID
         * @param {string} memberId ID of the member to delete from this conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteConversationMember(
            conversationId,
            memberId,
            options
        ) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsDeleteConversationMember(
                    conversationId,
                    memberId,
                    options
                )(fetch, basePath)
        },
        /**
         * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
         * @summary GetActivityMembers
         * @param {string} conversationId Conversation ID
         * @param {string} activityId Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetActivityMembers(conversationId, activityId, options) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsGetActivityMembers(
                    conversationId,
                    activityId,
                    options
                )(fetch, basePath)
        },
        /**
         * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
         * @summary GetConversationMembers
         * @param {string} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationMembers(conversationId, options) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsGetConversationMembers(conversationId, options)(
                fetch,
                basePath
            )
        },
        /**
         * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
         * @summary GetConversationPagedMembers
         * @param {string} conversationId Conversation ID
         * @param {number} [pageSize] Suggested page size
         * @param {string} [continuationToken] Continuation Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationPagedMembers(
            conversationId,
            pageSize,
            continuationToken,
            options
        ) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsGetConversationPagedMembers(
                    conversationId,
                    pageSize,
                    continuationToken,
                    options
                )(fetch, basePath)
        },
        /**
         * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
         * @summary GetConversations
         * @param {string} [continuationToken] skip or continuation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversations(continuationToken, options) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsGetConversations(continuationToken, options)(
                fetch,
                basePath
            )
        },
        /**
         * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary ReplyToActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId the reply is to (OPTIONAL)
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsReplyToActivity(
            conversationId,
            activityId,
            activity,
            options
        ) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsReplyToActivity(
                    conversationId,
                    activityId,
                    activity,
                    options
                )(fetch, basePath)
        },
        /**
         * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
         * @summary SendConversationHistory
         * @param {string} conversationId Conversation ID
         * @param {Transcript} history Historic activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendConversationHistory(conversationId, history, options) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsSendConversationHistory(
                    conversationId,
                    history,
                    options
                )(fetch, basePath)
        },
        /**
         * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary SendToConversation
         * @param {string} conversationId Conversation ID
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendToConversation(conversationId, activity, options) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsSendToConversation(
                    conversationId,
                    activity,
                    options
                )(fetch, basePath)
        },
        /**
         * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
         * @summary UpdateActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to update
         * @param {Activity} activity replacement Activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUpdateActivity(
            conversationId,
            activityId,
            activity,
            options
        ) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsUpdateActivity(
                    conversationId,
                    activityId,
                    activity,
                    options
                )(fetch, basePath)
        },
        /**
         * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
         * @summary UploadAttachment
         * @param {string} conversationId Conversation ID
         * @param {AttachmentData} attachmentUpload Attachment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUploadAttachment(
            conversationId,
            attachmentUpload,
            options
        ) {
            return exports
                .ConversationsApiFp(configuration)
                .conversationsUploadAttachment(
                    conversationId,
                    attachmentUpload,
                    options
                )(fetch, basePath)
        },
    }
}
/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
class ConversationsApi extends BaseAPI {
    /**
     * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
     * @summary CreateConversation
     * @param {ConversationParameters} parameters Parameters to create the conversation from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsCreateConversation(parameters, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsCreateConversation(parameters, options)(
            this.fetch,
            this.basePath
        )
    }
    /**
     * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     * @summary DeleteActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsDeleteActivity(conversationId, activityId, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsDeleteActivity(
                conversationId,
                activityId,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
     * @summary DeleteConversationMember
     * @param {string} conversationId Conversation ID
     * @param {string} memberId ID of the member to delete from this conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsDeleteConversationMember(conversationId, memberId, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsDeleteConversationMember(
                conversationId,
                memberId,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     * @summary GetActivityMembers
     * @param {string} conversationId Conversation ID
     * @param {string} activityId Activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetActivityMembers(conversationId, activityId, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsGetActivityMembers(
                conversationId,
                activityId,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     * @summary GetConversationMembers
     * @param {string} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversationMembers(conversationId, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsGetConversationMembers(conversationId, options)(
            this.fetch,
            this.basePath
        )
    }
    /**
     * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
     * @summary GetConversationPagedMembers
     * @param {string} conversationId Conversation ID
     * @param {number} [pageSize] Suggested page size
     * @param {string} [continuationToken] Continuation Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversationPagedMembers(
        conversationId,
        pageSize,
        continuationToken,
        options
    ) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsGetConversationPagedMembers(
                conversationId,
                pageSize,
                continuationToken,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
     * @summary GetConversations
     * @param {string} [continuationToken] skip or continuation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversations(continuationToken, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsGetConversations(continuationToken, options)(
            this.fetch,
            this.basePath
        )
    }
    /**
     * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary ReplyToActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId the reply is to (OPTIONAL)
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsReplyToActivity(
        conversationId,
        activityId,
        activity,
        options
    ) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsReplyToActivity(
                conversationId,
                activityId,
                activity,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
     * @summary SendConversationHistory
     * @param {string} conversationId Conversation ID
     * @param {Transcript} history Historic activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsSendConversationHistory(conversationId, history, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsSendConversationHistory(
                conversationId,
                history,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary SendToConversation
     * @param {string} conversationId Conversation ID
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsSendToConversation(conversationId, activity, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsSendToConversation(
                conversationId,
                activity,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
     * @summary UpdateActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to update
     * @param {Activity} activity replacement Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsUpdateActivity(conversationId, activityId, activity, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsUpdateActivity(
                conversationId,
                activityId,
                activity,
                options
            )(this.fetch, this.basePath)
    }
    /**
     * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     * @summary UploadAttachment
     * @param {string} conversationId Conversation ID
     * @param {AttachmentData} attachmentUpload Attachment data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsUploadAttachment(conversationId, attachmentUpload, options) {
        return exports
            .ConversationsApiFp(this.configuration)
            .conversationsUploadAttachment(
                conversationId,
                attachmentUpload,
                options
            )(this.fetch, this.basePath)
    }
}
exports.ConversationsApi = ConversationsApi
//# sourceMappingURL=api.js.map
